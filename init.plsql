CONNECT SYS/oracle@XE_LOCAL AS SYSDBA;

/

DECLARE
    V_COUNT NUMBER;
BEGIN
    SELECT COUNT ( * ) INTO V_COUNT
    FROM DBA_USERS T
    WHERE T.USERNAME='CSERKESZ_ADMIN';
    SELECT COUNT ( * ) INTO V_COUNT
    FROM DBA_USERS T
    WHERE T.USERNAME='CSERKESZ_ADMIN';
    IF V_COUNT = 1 THEN
        EXECUTE IMMEDIATE 'DROP USER CSERKESZ_ADMIN CASCADE';
    END IF;
END;
/

CREATE USER CSERKESZ_ADMIN IDENTIFIED BY 12345678 DEFAULT TABLESPACE USERS QUOTA UNLIMITED ON USERS;

/

-- Privileges for the admin user
GRANT CREATE SESSION TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT CREATE COMMENT TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT CREATE TRIGGER TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT CREATE TABLE TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT CREATE VIEW TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT CREATE SEQUENCE TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT CREATE PROCEDURE TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT CREATE TYPE TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT CREATE JOB TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT CREATE ANY DIRECTORY TO CSERKESZ_ADMIN WITH ADMIN OPTION;

GRANT ADMINISTER DATABASE TRIGGER TO CSERKESZ_ADMIN;

ALTER SESSION SET CURRENT_SCHEMA=CSERKESZ_ADMIN;

CONNECT CSERKESZ_ADMIN/12345678@XE_LOCAL;

/

--TABLES
CREATE TABLE MEMBERS (
    MEMBER_ID NUMBER PRIMARY KEY,
    FIRST_NAME VARCHAR2 ( 40 ) NOT NULL,
    LAST_NAME VARCHAR2 ( 80 ) NOT NULL,
    MOTHERS_NAME VARCHAR2 ( 120 ) NOT NULL,
    MOTHERS_TELEPHONE_NUMBER VARCHAR2 ( 12 ) NOT NULL,
    MOTHERS_EMAIL VARCHAR2 ( 60 ) NOT NULL,
    MEMBER_EMAIL VARCHAR2 ( 60 ) DEFAULT NULL,
    MEMBER_TELEPHONE_NUMBER VARCHAR2 ( 12 ) DEFAULT NULL,
    BIRTH_DATE DATE DEFAULT NULL,
    ORS_ID NUMBER DEFAULT NULL,
    PATROL_ID NUMBER DEFAULT NULL,
    CONSTRAINT MEMBERS_EMAIL_U UNIQUE ( MEMBER_EMAIL ),
    CONSTRAINT MEMBER_INFORMATIO_U UNIQUE ( FIRST_NAME, LAST_NAME, MOTHERS_NAME, MOTHERS_TELEPHONE_NUMBER, MOTHERS_EMAIL ),
    CONSTRAINT MEMBERS_TELEPHONE_NUMBER_U UNIQUE ( MEMBER_TELEPHONE_NUMBER )
);

/

COMMENT ON TABLE MEMBERS IS 'A tábla a csapat összes tagját és információját tárolja';
COMMENT ON COLUMN MEMBERS.ORS_ID IS 'Azonosítja hogy melyik csoporthoz/őrshöz tartozik a tag';
COMMENT ON COLUMN MEMBERS.PATROL_ID IS 'Azonosítja hogy melyik rajhoz tartozik a tag';

/

CREATE TABLE ADDRESS (
    ADDRESS_ID NUMBER PRIMARY KEY,
    ZIP_CODE VARCHAR2 ( 10 ) NOT NULL,
    COUNTRY VARCHAR2 ( 50 ) NOT NULL,
    CITY VARCHAR2 ( 50 ) NOT NULL,
    STREET_NAME VARCHAR2 ( 100 ) NOT NULL,
    STREET_TYPE VARCHAR2 ( 40 ) NOT NULL,
    HOUSE_NUMBER VARCHAR2 ( 30 ) NOT NULL,
    CONSTRAINT ZIP_CH CHECK ( REGEXP_LIKE ( ZIP_CODE, '^[0-9]{1,10}$' ) )
);

COMMENT ON TABLE ADDRESS IS 'A tagok címeit tárolja ismétlés mentesen';
/

CREATE TABLE ADDRESS_MEMBER_ASS (
    ADDRESS_ID NUMBER NOT NULL,
    MEMBER_ID NUMBER NOT NULL,
    CONSTRAINT MEMBER_ADDRESS_PK PRIMARY KEY ( ADDRESS_ID, MEMBER_ID )
);

COMMENT ON TABLE ADDRESS_MEMBER_ASS IS 'A tagok és címeiket tartalmazó tábla, összeköti a tagot a címével';
/

CREATE TABLE RANK_DICTIONARY (
    RANK_ID NUMBER PRIMARY KEY,
    RANK_NAME VARCHAR ( 50 ) NOT NULL,
    CONSTRAINT RANK_NAME_U UNIQUE ( RANK_NAME )
);

COMMENT ON TABLE RANK_DICTIONARY IS 'A csapaton belüli rangok és jogok nevét és azonosítóját tárolja';
/

CREATE TABLE RANK_PRIVILEGES (
    STATUS_ID NUMBER PRIMARY KEY,
    MEMBER_ID NUMBER NOT NULL,
    RANK_ID NUMBER NOT NULL,
    PROMOTION_TIME_END TIMESTAMP DEFAULT SYSTIMESTAMP + INTERVAL '1' YEAR,
    CONSTRAINT MEMBER_RANK_U UNIQUE ( MEMBER_ID, RANK_ID )
);

COMMENT ON TABLE RANK_PRIVILEGES IS 'A tagok és rangjaik/jogaikat köti össze';
COMMENT ON COLUMN RANK_PRIVILEGES.PROMOTION_TIME_END IS 'A megbízatás/jogosultság végét jelzi';
/

CREATE TABLE ORS (
    ORS_ID NUMBER PRIMARY KEY,
    ORS_NAME VARCHAR ( 100 ) NOT NULL,
    PATROL_ID NUMBER NOT NULL,
    LEADER_ID NUMBER,
    CONSTRAINT ORS_NAME_U UNIQUE ( ORS_NAME )
);

COMMENT ON TABLE ORS IS 'A csapaton belül működő őrsöket/csoportokat tárolja';
/

CREATE TABLE PATROL (
    PATROL_ID NUMBER PRIMARY KEY,
    PATROL_NAME VARCHAR2 ( 100 ) NOT NULL,
    LEADER_ID NUMBER,
    CONSTRAINT NAME_U UNIQUE ( PATROL_NAME )
);

COMMENT ON TABLE PATROL IS 'A csapaton belül működő rajokat tárolja, ezek csoportosítják az őrsöket/csoportokat';
/

CREATE TABLE MEETING (
    MEETING_ID NUMBER PRIMARY KEY,
    MEETING_CONTENT CLOB NOT NULL,
    AUTHOR_ID NUMBER NOT NULL,
    EVENT_ID NUMBER NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    MODIFIED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

COMMENT ON TABLE MEETING IS 'Jegyzőkönyvek amiket különböző programokra írnak a vezetőség tagjai és a szervezésben résztvevők';
COMMENT ON COLUMN MEETING.AUTHOR_ID IS 'Azonosítja a jegyzőkönyv jegyzőjét, szerzőjét';
COMMENT ON COLUMN MEETING.EVENT_ID IS 'Azonosítja a programot, amivel összefüggésben írták a dokumentumot';
/

CREATE TABLE GATHERING_REPORTS (
    REPORT_ID NUMBER PRIMARY KEY,
    REPORT_CONTENT CLOB NOT NULL,
    AUTHOR_ID NUMBER NOT NULL,
    ORS_ID NUMBER NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    MODIFIED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

COMMENT ON TABLE GATHERING_REPORTS IS 'Az őrsöknek foglalkozások vannak tartva, ahol egy arra kijelölt vezető végez nevelő munkát, az ő munkáját segítve készülnek jelentések ezekről az alkalmakról';
COMMENT ON COLUMN GATHERING_REPORTS.AUTHOR_ID IS 'Azonosítja a jelentés jegyzőjét, szerzőjét';
COMMENT ON COLUMN GATHERING_REPORTS.ORS_ID IS 'Azonosítja a csoportot';
/

CREATE TABLE EVENTS (
    EVENT_ID NUMBER PRIMARY KEY,
    EVENT_NAME VARCHAR2 ( 100 ) NOT NULL,
    EVENT_DESCRIPTION VARCHAR2 ( 2000 ),
    DATE_START TIMESTAMP NOT NULL,
    DATE_END TIMESTAMP NOT NULL,
    CONSTRAINT EVENTS_DATE_START_END_CK CHECK ( DATE_START < DATE_END )
);

COMMENT ON TABLE EVENTS IS 'A csapat programjai';
/

CREATE TABLE DUTIES (
    DUTY_ID NUMBER PRIMARY KEY,
    DUTY_NAME VARCHAR2 ( 100 ) NOT NULL,
    DUTY_DESCRIPTION VARCHAR2 ( 500 )
);

COMMENT ON TABLE DUTIES IS 'A programokra kiosztható feladatok, felelős körök';
/

CREATE TABLE EVENT_DUTIES_ASS (
    EVENT_ID NUMBER NOT NULL,
    DUTY_ID NUMBER NOT NULL,
    MEMBER_ID NUMBER NOT NULL,
    ASSIGNMENT_END_DATE TIMESTAMP DEFAULT ADD_MONTHS ( SYSDATE, 1 ),
    PRIMARY KEY ( EVENT_ID, DUTY_ID, MEMBER_ID )
);

COMMENT ON TABLE EVENT_DUTIES_ASS IS 'A programok és azokra kijelölt felelősöket köti össze, a feladatot is azonositva';
/

-- CREATE TABLE POSTS (
--     POST_ID NUMBER PRIMARY KEY,
--     POST_NAME VARCHAR2 ( 100 ) NOT NULL,
--     POST_DESCRIPTION VARCHAR2 ( 2000 ),
--     POST_TYPE VARCHAR2 ( 4 ) NOT NULL -- ['NEWS', 'BLOG', 'KNOW']
-- );

-- COMMENT ON TABLE EVENT_DUTIES_ASS IS 'A csapat weboldalának főfolyamának tartalmait tartalmazza';
/

-- Kivéve azért mert érdemben nem rak hozzá a feladathoz, csak mennyiség lenne
-- CREATE TABLE KNOWLEDGE (
--     KNOWLEDGE_ID NUMBER PRIMARY KEY,
--     KNOWLEDGE_AUTHOR_ID NUMBER NOT NULL,
--     KNOWLEDGE_NAME VARCHAR2 ( 100 ) NOT NULL,
--     CONSTRAINT KNOWLEDGE_AUTHOR_FK FOREIGN KEY ( KNOWLEDGE_AUTHOR_ID ) REFERENCES MEMBERS ( MEMBER_ID )
-- );

-- /

-- CREATE TABLE KNOWLEDGE_MEDIA_ASS (
--     KNOWLEDGE_ID NUMBER NOT NULL,
--     MEDIA_ID NUMBER NOT NULL,
--     PRIMARY KEY ( KNOWLEDGE_ID, MEDIA_ID ),
--     CONSTRAINT KNOWLEDGE_MEDIA_KNOWLEDGE_FK FOREIGN KEY ( KNOWLEDGE_ID ) REFERENCES KNOWLEDGE ( KNOWLEDGE_ID ),
--     CONSTRAINT KNOWLEDGE_MEDIA_MEDIA_FK FOREIGN KEY ( MEDIA_ID ) REFERENCES MEDIA ( MEDIA_ID )
-- );

-- /

-- CREATE TABLE MEDIA (
--     MEDIA_ID NUMBER PRIMARY KEY,
--     MEDIA_NAME VARCHAR2 ( 50 ) NOT NULL,
--     MEDIA_VALUE BLOB,
--     MEDIA_TYPE VARCHAR2 ( 6 ) NOT NULL,
--     CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
-- );
-- /
-- SZEMÉLYES INFÓKNAK [MEMBERS, ADDRESS, USERS]
CREATE TABLE PERSONAL_HISTORY (
    LOG_ID NUMBER PRIMARY KEY,
    CHANGER VARCHAR2 ( 40 ) NOT NULL,
    LOG_MSSG VARCHAR2 ( 1000 ) NOT NULL,
    MODIFIED_TABLE VARCHAR2 ( 30 ) NOT NULL,
    TR_NAME VARCHAR2 ( 30 ) NOT NULL,
    TR_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

COMMENT ON TABLE PERSONAL_HISTORY IS 'A csapat személyes adatainak változásait logolja';
/

-- JELENTÉSEKNEK [MEETINGS, GATHERINGS]
CREATE TABLE REPORT_HISTORY (
    LOG_ID NUMBER PRIMARY KEY,
    CHANGER VARCHAR2 ( 40 ) NOT NULL,
    LOG_MSSG VARCHAR2 ( 1000 ) NOT NULL,
    MODIFIED_TABLE VARCHAR2 ( 30 ) NOT NULL,
    TR_NAME VARCHAR2 ( 30 ) NOT NULL,
    TR_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

COMMENT ON TABLE REPORT_HISTORY IS 'A csapat jelentéseinek eseményeit logolja';
/

-- MEGBÍZATÁSÁNAK ÉS FELÉPÍTÉSÜNK [RANK_DICTIONARY, RANK_PRIVILEGES, DUTIES, ORS, PATROL]
CREATE TABLE INTERNAL_ASSIGNS_HISTORY (
    LOG_ID NUMBER PRIMARY KEY,
    CHANGER VARCHAR2 ( 40 ) NOT NULL,
    LOG_MSSG VARCHAR2 ( 1000 ) NOT NULL,
    MODIFIED_TABLE VARCHAR2 ( 30 ) NOT NULL,
    TR_NAME VARCHAR2 ( 30 ) NOT NULL,
    TR_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

COMMENT ON TABLE INTERNAL_ASSIGNS_HISTORY IS 'A csapat belső szerkezetének változásit logolja';
/

-- Publicisztika [EVENT, DUTIES, EV-DU_ASS, POST, MEDIA, KNOWLEDGE, KNW-MD_ASS]
CREATE TABLE PUBLIC_ACTIVITIES_HISTORY (
    LOG_ID NUMBER PRIMARY KEY,
    CHANGER VARCHAR2 ( 40 ) NOT NULL,
    LOG_MSSG VARCHAR2 ( 1000 ) NOT NULL,
    MODIFIED_TABLE VARCHAR2 ( 30 ) NOT NULL,
    TR_NAME VARCHAR2 ( 30 ) NOT NULL,
    TR_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

COMMENT ON TABLE PUBLIC_ACTIVITIES_HISTORY IS 'A csapat kívűlről is látható változásit logolja';
/

-- CONSTRAINTS FOR TABLES
--MEMBERS
ALTER TABLE MEMBERS
    ADD CONSTRAINT MEMBERS_ORS_FK FOREIGN KEY (
        ORS_ID
    )
        REFERENCES ORS (
            ORS_ID
        );

ALTER TABLE MEMBERS
    ADD CONSTRAINT MEMBERS_PATROL_FK FOREIGN KEY (
        PATROL_ID
    )
        REFERENCES PATROL (
            PATROL_ID
        );

-- ADDRESS_MEMBER_ASS
ALTER TABLE ADDRESS_MEMBER_ASS
    ADD CONSTRAINT ADDRESS_PK FOREIGN KEY (
        ADDRESS_ID
    )
        REFERENCES ADDRESS (
            ADDRESS_ID
        );

ALTER TABLE ADDRESS_MEMBER_ASS
    ADD CONSTRAINT MEMBER_PK FOREIGN KEY (
        MEMBER_ID
    )
        REFERENCES MEMBERS (
            MEMBER_ID
        );

-- RANK_PRIVILEGES
ALTER TABLE RANK_PRIVILEGES
    ADD CONSTRAINT MEMBER_RANK_FK FOREIGN KEY (
        MEMBER_ID
    )
        REFERENCES MEMBERS (
            MEMBER_ID
        );

ALTER TABLE RANK_PRIVILEGES
    ADD CONSTRAINT RANK_DICTIONARY_FK FOREIGN KEY (
        RANK_ID
    )
        REFERENCES RANK_DICTIONARY (
            RANK_ID
        );

--ORS
ALTER TABLE ORS
    ADD CONSTRAINT ORS_PATROL_FK FOREIGN KEY (
        PATROL_ID
    )
        REFERENCES PATROL (
            PATROL_ID
        );

ALTER TABLE ORS
    ADD CONSTRAINT ORS_LEADER_FK FOREIGN KEY (
        LEADER_ID
    )
        REFERENCES MEMBERS (
            MEMBER_ID
        );

-- PATROL
ALTER TABLE PATROL
    ADD CONSTRAINT PATROL_LEADER_FK FOREIGN KEY (
        LEADER_ID
    )
        REFERENCES MEMBERS (
            MEMBER_ID
        );

-- MEETING
ALTER TABLE MEETING
    ADD CONSTRAINT MEETING_EVENT_FK FOREIGN KEY (
        EVENT_ID
    )
        REFERENCES EVENTS (
            EVENT_ID
        );

ALTER TABLE MEETING
    ADD CONSTRAINT MEETING_AUTHOR_FK FOREIGN KEY (
        AUTHOR_ID
    )
        REFERENCES MEMBERS (
            MEMBER_ID
        );

-- GATHERING_REPORTS
ALTER TABLE GATHERING_REPORTS
    ADD CONSTRAINT GATHERING_AUTHOR_FK FOREIGN KEY (
        AUTHOR_ID
    )
        REFERENCES MEMBERS (
            MEMBER_ID
        );

ALTER TABLE GATHERING_REPORTS
    ADD CONSTRAINT GATHERING_ORS_FK FOREIGN KEY (
        ORS_ID
    )
        REFERENCES ORS (
            ORS_ID
        );

--EVENT_DUTIES_ASS
ALTER TABLE EVENT_DUTIES_ASS
    ADD CONSTRAINT EVENT_DUTIES_CONN_EVENT_FK FOREIGN KEY (
        EVENT_ID
    )
        REFERENCES EVENTS (
            EVENT_ID
        );

ALTER TABLE EVENT_DUTIES_ASS
    ADD CONSTRAINT EVENT_DUTIES_CONN_DUTY_FK FOREIGN KEY (
        DUTY_ID
    )
        REFERENCES DUTIES (
            DUTY_ID
        );

ALTER TABLE EVENT_DUTIES_ASS
    ADD CONSTRAINT EVENT_DUTIES_CONN_MEMBER_FK FOREIGN KEY (
        MEMBER_ID
    )
        REFERENCES MEMBERS (
            MEMBER_ID
        );

/

--Indexek
CREATE INDEX ADDRESS_CITY_I ON ADDRESS ( CITY );

/

CREATE INDEX ADDRESS_STREET_I ON ADDRESS ( STREET_NAME );

/

CREATE INDEX ADDRESS_FULL_STREET_I ON ADDRESS ( STREET_NAME, STREET_TYPE, HOUSE_NUMBER );

/

-- --Posts
-- CREATE INDEX POST_TYPE_I ON POSTS ( POST_TYPE );

-- /

--Members
CREATE INDEX MEMBER_NAME_I ON MEMBERS ( FIRST_NAME, LAST_NAME );

/

CREATE INDEX MEMBERS_M_I ON MEMBERS ( MOTHERS_NAME, MOTHERS_TELEPHONE_NUMBER, MOTHERS_EMAIL );

/

CREATE INDEX MEMBERS_ORS_I ON MEMBERS ( ORS_ID );

/

--Events
CREATE INDEX EVENT_DATE_I ON EVENTS ( DATE_START );

/

--Histories
--Public
CREATE INDEX PUBLIC_ACTIVITIES_CHANGER_I ON PUBLIC_ACTIVITIES_HISTORY ( CHANGER );

/

CREATE INDEX PUBLIC_ACTIVITIES_TABLE_I ON PUBLIC_ACTIVITIES_HISTORY ( MODIFIED_TABLE );

/

--Internal
CREATE INDEX INTERNAL_ASSIGNS_CHANGER_I ON INTERNAL_ASSIGNS_HISTORY ( CHANGER );

/

CREATE INDEX INTERNAL_ASSIGNS_TABLE_I ON INTERNAL_ASSIGNS_HISTORY ( MODIFIED_TABLE );

/

--Report
CREATE INDEX REPORT_CHANGER_I ON REPORT_HISTORY ( CHANGER );

/

CREATE INDEX REPORT_TABLE_I ON REPORT_HISTORY ( MODIFIED_TABLE );

/

--Personal
CREATE INDEX PERSONAL_CHANGER_I ON PERSONAL_HISTORY ( CHANGER );

/

CREATE INDEX PERSONAL_TABLE_I ON PERSONAL_HISTORY ( MODIFIED_TABLE );

/

--SZEKVENCIÁK
CREATE SEQUENCE REPORTS_SEQ
START WITH 1300
INCREMENT BY 1;

CREATE SEQUENCE MEMBERS_SEQ
START WITH 140
INCREMENT BY 1;

CREATE SEQUENCE ADDRESS_SEQ
START WITH 10
INCREMENT BY 1;

CREATE SEQUENCE ORS_PATROL_SEQ
START WITH 166
INCREMENT BY 1;

CREATE SEQUENCE POSTS_SEQ
START WITH 1350
INCREMENT BY 1;

-- CREATE SEQUENCE KNOWLEDGE_MEDIA_SEQ
-- START WITH 1300
-- INCREMENT BY 1;

CREATE SEQUENCE GATHERING_REPORT_HIS_SEQ
START WITH 8300
INCREMENT BY 1;

CREATE SEQUENCE RANKS_SEQ
START WITH 4450
INCREMENT BY 1;

CREATE SEQUENCE HISTORY_SEQ
START WITH 6700
INCREMENT BY 1;

CREATE SEQUENCE DUTY_SEQ
START WITH 6800
INCREMENT BY 1;

--TYPES

CREATE TYPE DUTY_TY IS
    OBJECT (
        DUTY_ID NUMBER,
        DUTY_NAME VARCHAR2 ( 100 ),
        DUTY_DESCRIPTION VARCHAR2 ( 500 )
    );
/

CREATE OR REPLACE TYPE T_DUTY_TY IS
    TABLE OF DUTY_TY;
/

CREATE OR REPLACE TYPE ADDRESS_TY AS
    OBJECT (
        ZIP_CODE VARCHAR2 ( 10 ),
        COUNTRY VARCHAR2 ( 50 ),
        CITY VARCHAR2 ( 50 ),
        STREET_NAME VARCHAR2 ( 100 ),
        STREET_TYPE VARCHAR2 ( 40 ),
        HOUSE_NUMBER VARCHAR2 ( 30 )
    );
/

CREATE OR REPLACE TYPE MEMBER_TY AS
    OBJECT (
        FIRST_NAME VARCHAR2 ( 40 ),
        LAST_NAME VARCHAR2 ( 80 ),
        MOTHERS_NAME VARCHAR2 ( 120 ),
        MOTHERS_TELEPHONE_NUMBER VARCHAR2 ( 12 ),
        MOTHERS_EMAIL VARCHAR2 ( 60 ),
        MEMBER_EMAIL VARCHAR2 ( 60 ),
        MEMBER_TELEPHONE_NUMBER VARCHAR2 ( 12 ),
        BIRTH_DATE DATE,
        ORS_ID NUMBER,
        PATROL_ID NUMBER,
        CONSTRUCTOR FUNCTION MEMBER_TY ( FIRST_NAME VARCHAR2, LAST_NAME VARCHAR2, MOTHERS_NAME VARCHAR2, MOTHERS_TELEPHONE_NUMBER VARCHAR2, MOTHERS_EMAIL VARCHAR2, ORS_ID NUMBER ) RETURN SELF AS RESULT
    );
/

CREATE OR REPLACE TYPE BODY MEMBER_TY AS

    CONSTRUCTOR FUNCTION MEMBER_TY (
        FIRST_NAME VARCHAR2,
        LAST_NAME VARCHAR2,
        MOTHERS_NAME VARCHAR2,
        MOTHERS_TELEPHONE_NUMBER VARCHAR2,
        MOTHERS_EMAIL VARCHAR2,
        ORS_ID NUMBER
    ) RETURN SELF AS
        RESULT IS
            BEGIN SELF .FIRST_NAME := FIRST_NAME;
        SELF   .LAST_NAME := LAST_NAME;
        SELF   .MOTHERS_NAME := MOTHERS_NAME;
        SELF   .MOTHERS_TELEPHONE_NUMBER := MOTHERS_TELEPHONE_NUMBER;
        SELF   .MOTHERS_EMAIL := MOTHERS_EMAIL;
        SELF   .ORS_ID := ORS_ID;
        RETURN;
    END;
END;
/

CREATE TYPE R_MEETING_TY AS
    OBJECT (
        MEETING_ID NUMBER,
        MEETING_CONTENT CLOB,
        AUTHOR_ID NUMBER,
        EVENT_ID NUMBER,
        CREATED_AT TIMESTAMP ( 6 )
    );
/

CREATE OR REPLACE TYPE T_MEETING_TY IS
    TABLE OF R_MEETING_TY;
/

CREATE TYPE R_GATHERING_REPORT_TY AS
    OBJECT (
        REPORT_ID NUMBER,
        REPORT_CONTENT CLOB,
        AUTHOR_ID NUMBER,
        ORS_ID NUMBER,
        CREATED_AT TIMESTAMP ( 6 )
    );
/

CREATE OR REPLACE TYPE T_GATHERING_REPORT_TY IS
    TABLE OF R_GATHERING_REPORT_TY;
/

-- VIEWS
--VIEWS/ORS_AND_MEMBERS.PLSQL
CREATE OR REPLACE VIEW ORS_AND_MEMBERS AS
    SELECT ORS_ID,
        O.LEADER_ID                                                               AS LEADER_ID,
        CASE
            WHEN O.LEADER_ID IS NOT NULL THEN
                O.LEADER_ID || ','
            ELSE
                ''
        END || LISTAGG ( M.MEMBER_ID, ',' ) WITHIN GROUP ( ORDER BY M.MEMBER_ID ) AS MEMBERS_OF_ORS
    FROM ORS     O
        RIGHT OUTER JOIN MEMBERS M
        USING ( ORS_ID )
    GROUP BY ORS_ID,
        LEADER_ID;

/

CREATE OR REPLACE VIEW GROUP_LEADERS_VW AS
    SELECT O.ORS_ID     AS ORS_ID,
        RP.MEMBER_ID AS LEADER_ID
    FROM RANK_PRIVILEGES RP
        RIGHT OUTER JOIN ORS O
        ON RP.MEMBER_ID = O.LEADER_ID;

/

--VIEWS/MEMBERS_RANK.PLSQL
CREATE OR REPLACE VIEW MEMBERS_RANK_VW AS
    SELECT MEMBER_ID,
        M.FIRST_NAME || ' ' || M.LAST_NAME                                   AS MEMBER_NAME,
        LISTAGG ( RD.RANK_NAME, ';' ) WITHIN GROUP ( ORDER BY RD.RANK_NAME ) AS ALL_RANKS
    FROM RANK_PRIVILEGES RP
        INNER JOIN MEMBERS M
        USING ( MEMBER_ID )
        INNER JOIN RANK_DICTIONARY RD
        USING ( RANK_ID )
    GROUP BY MEMBER_ID,
        M.FIRST_NAME,
        M.LAST_NAME;

/

--DIRECTORY - UNCOMMENT THE CORRECT PARTS!
-- Unix/Linux
-- CREATE OR REPLACE DIRECTORY FILES_FOR_REPORT AS '&ORACLE_BASE/reports/temp';
-- Windows
-- CREATE OR REPLACE DIRECTORY FILES_FOR_REPORT AS '%ORACLE_HOME%\reports\temp';

-- CREATE OR REPLACE DIRECTORY 'FILES_FOR_REPORT' AS '/db2_hrphee/temp';

-- GRANT READ, WRITE ON DIRECTORY FILES_FOR_REPORT TO PUBLIC;

-- PACKAGES
--PACKEGES/EXCEPTIONS.PCK
CREATE OR REPLACE PACKAGE EXCEPTIONS_PKG IS
    INVALID_FORMAT_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( INVALID_FORMAT_EXC, -20001 );
    INVALID_PRIVILEGE_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( INVALID_PRIVILEGE_EXC, -20002 );
    ASSIGMENT_DATE_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( ASSIGMENT_DATE_EXC, -20003 );
    NOT_FOUND_ORS_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( NOT_FOUND_ORS_EXC, -20004 );
    MISSING_PARAM_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( MISSING_PARAM_EXC, -20005 );
    INVALID_IDENTIFICATION EXCEPTION;
    PRAGMA EXCEPTION_INIT ( INVALID_IDENTIFICATION, -20006 );
END EXCEPTIONS_PKG;
/

CREATE OR REPLACE PACKAGE BODY EXCEPTIONS_PKG IS
    INVALID_FORMAT_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( INVALID_FORMAT_EXC, -20001 );
    INVALID_PRIVILEGE_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( INVALID_PRIVILEGE_EXC, -20002 );
    ASSIGMENT_DATE_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( ASSIGMENT_DATE_EXC, -20003 );
    NOT_FOUND_ORS_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( NOT_FOUND_ORS_EXC, -20004 );
    MISSING_PARAM_EXC EXCEPTION;
    PRAGMA EXCEPTION_INIT ( MISSING_PARAM_EXC, -20005 );
    INVALID_IDENTIFICATION EXCEPTION;
    PRAGMA EXCEPTION_INIT ( INVALID_IDENTIFICATION, -20006 );
END EXCEPTIONS_PKG;
/

--PACKEGES/CONSTANTS.PCK
CREATE OR REPLACE PACKAGE CONSTANTS_PKG AS
    TYPE T_RANK_NAME_TY IS
        TABLE OF VARCHAR2 ( 50 ) NOT NULL INDEX BY VARCHAR2 ( 10 );
    RANKS_NAMES T_RANK_NAME_TY;

    PROCEDURE INIT_RANKS;
END CONSTANTS_PKG;
/

CREATE OR REPLACE PACKAGE BODY CONSTANTS_PKG AS

    PROCEDURE INIT_RANKS IS
        CURSOR C_RANK_NAMES IS
        SELECT *
        FROM RANK_DICTIONARY;
        R_RANK RANK_DICTIONARY%ROWTYPE;
    BEGIN
        OPEN C_RANK_NAMES;
        LOOP
            FETCH C_RANK_NAMES INTO R_RANK;
            EXIT WHEN C_RANK_NAMES%NOTFOUND;
            RANKS_NAMES ( REGEXP_REPLACE ( R_RANK.RANK_NAME, '^(\S)\S*\s+(\S)\S*.*', '\1\2' ) ) := LTRIM ( RTRIM ( UPPER ( R_RANK.RANK_NAME ) ) );
        END LOOP;

        CLOSE C_RANK_NAMES;
    EXCEPTION
        WHEN OTHERS THEN
            IF C_RANK_NAMES%ISOPEN THEN
                CLOSE C_RANK_NAMES;
            END IF;

            DBMS_OUTPUT.PUT_LINE ( 'Error on the constant pkg'||REGEXP_REPLACE ( R_RANK.RANK_NAME, '^(\S)\S*\s+(\S)\S*.*', '\1\2' ) || '----' ||REGEXP_REPLACE ( LTRIM ( RTRIM ( UPPER ( R_RANK.RANK_NAME ) ) ) , '\s+', '_' ) );
    END INIT_RANKS;
BEGIN
    INIT_RANKS;
END CONSTANTS_PKG;
/

--PACKEGES/RANK_DIC.PCK

CREATE OR REPLACE PACKAGE RANK_DIC_PKG IS

    FUNCTION GET_RANK_ID_BY_NAME (
        P_RANK_NAME IN RANK_DICTIONARY.RANK_NAME%TYPE
    ) RETURN RANK_DICTIONARY.RANK_ID%TYPE;

    FUNCTION HAVE_MEMBER_RANK_BY_NAME_FUNC (
        P_MEMBER_ID RANK_PRIVILEGES.MEMBER_ID%TYPE,
        P_RANK_NAME RANK_DICTIONARY.RANK_NAME%TYPE
    ) RETURN NUMBER;

    FUNCTION HAVE_MEMBER_RANK_BY_ID_FUNC (
        P_MEMBER_ID RANK_PRIVILEGES.MEMBER_ID%TYPE,
        P_RANK_ID RANK_PRIVILEGES.RANK_ID%TYPE
    ) RETURN NUMBER;

    PROCEDURE CREATE_NEW_RANK (
        P_RANK_NAME IN RANK_DICTIONARY.RANK_NAME%TYPE
    );

    PROCEDURE DELETE_RANK_BY_NAME (
        P_RANK_NAME RANK_DICTIONARY.RANK_NAME%TYPE
    );

    PROCEDURE DELETE_RANK_BY_ID (
        P_RANK_ID RANK_DICTIONARY.RANK_ID%TYPE
    );
END RANK_DIC_PKG;
/

CREATE OR REPLACE PACKAGE BODY RANK_DIC_PKG IS

    FUNCTION GET_RANK_ID_BY_NAME (
        P_RANK_NAME IN RANK_DICTIONARY.RANK_NAME%TYPE
    ) RETURN RANK_DICTIONARY.RANK_ID%TYPE AS
        V_RETURN RANK_DICTIONARY.RANK_ID%TYPE;
    BEGIN
        SELECT RANK_ID INTO V_RETURN
        FROM RANK_DICTIONARY
        WHERE RANK_NAME = P_RANK_NAME;
        RETURN V_RETURN;
    END GET_RANK_ID_BY_NAME;

    FUNCTION HAVE_MEMBER_RANK_BY_NAME_FUNC (
        P_MEMBER_ID RANK_PRIVILEGES.MEMBER_ID%TYPE,
        P_RANK_NAME RANK_DICTIONARY.RANK_NAME%TYPE
    ) RETURN NUMBER IS
        V_RESULT NUMBER;
    BEGIN
        SELECT CASE
                WHEN COUNT ( * ) > 0 THEN
                    1
                ELSE
                    0
            END INTO V_RESULT
        FROM MEMBERS_RANK_VW
        WHERE MEMBER_ID = P_MEMBER_ID AND
            INSTR ( ALL_RANKS, P_RANK_NAME ) <> 0;
        RETURN V_RESULT;
    END HAVE_MEMBER_RANK_BY_NAME_FUNC;

    FUNCTION HAVE_MEMBER_RANK_BY_ID_FUNC (
        P_MEMBER_ID RANK_PRIVILEGES.MEMBER_ID%TYPE,
        P_RANK_ID RANK_PRIVILEGES.RANK_ID%TYPE
    ) RETURN NUMBER IS
        V_RESULT NUMBER;
    BEGIN
        SELECT COUNT ( * ) INTO V_RESULT
        FROM RANK_PRIVILEGES
        WHERE MEMBER_ID = P_MEMBER_ID AND
            RANK_ID = P_RANK_ID;
        IF V_RESULT > 0 THEN
            RETURN 1;
        ELSE
            RETURN 0;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'ERROR at the member pkg HAVE_MEMBER_RANK_BY_ID_FUNC '|| SQLCODE ||' ' || SQLERRM );
    END HAVE_MEMBER_RANK_BY_ID_FUNC;

    PROCEDURE CREATE_NEW_RANK (
        P_RANK_NAME IN RANK_DICTIONARY.RANK_NAME%TYPE
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO RANK_DICTIONARY (
            RANK_NAME
        ) VALUES (
            P_RANK_NAME
        );
        COMMIT;
    END CREATE_NEW_RANK;

    PROCEDURE DELETE_RANK_BY_NAME (
        P_RANK_NAME RANK_DICTIONARY.RANK_NAME%TYPE
    ) IS
        V_RANK_COUNT NUMBER;
    BEGIN
        SELECT COUNT ( * ) INTO V_RANK_COUNT
        FROM RANK_PRIVILEGES
        WHERE RANK_PRIVILEGES.RANK_ID = (
                SELECT RANK_ID
                FROM RANK_DICTIONARY
                WHERE RANK_NAME = P_RANK_NAME
            );
        CASE
            WHEN V_RANK_COUNT = 0 THEN
                DELETE FROM RANK_DICTIONARY
                WHERE
                    RANK_NAME = P_RANK_NAME;
                COMMIT;
            WHEN V_RANK_COUNT > 0 THEN
                RAISE_APPLICATION_ERROR ( -20001, 'This rank is in use' );
        END CASE;
    END DELETE_RANK_BY_NAME;

    PROCEDURE DELETE_RANK_BY_ID (
        P_RANK_ID RANK_DICTIONARY.RANK_ID%TYPE
    ) IS
        V_RANK_COUNT NUMBER;
    BEGIN
        SELECT COUNT ( * ) INTO V_RANK_COUNT
        FROM RANK_PRIVILEGES
        WHERE RANK_PRIVILEGES.RANK_ID = P_RANK_ID;
        CASE
            WHEN V_RANK_COUNT = 0 THEN
                DELETE FROM RANK_DICTIONARY
                WHERE
                    RANK_NAME = P_RANK_ID;
                COMMIT;
            WHEN V_RANK_COUNT > 0 THEN
                RAISE_APPLICATION_ERROR ( -20001, 'This rank is in use' );
        END CASE;
    END DELETE_RANK_BY_ID;
END RANK_DIC_PKG;
/

-- PACKEGES/MEMBER.PCK
CREATE OR REPLACE PACKAGE MEMBER_PKG AS

    FUNCTION GET_RANDOM_GROUP_LEADER_FUNC RETURN MEMBERS.MEMBER_ID%TYPE;

    FUNCTION GET_RANDOM_PATROL_LEADER_FUNC RETURN MEMBERS.MEMBER_ID%TYPE;

    PROCEDURE CREATE_MEMBER (
        P_MEMBER IN MEMBER_TY
    );

    PROCEDURE CREATE_MEMBER_FOR_USER (
        P_MEMBER IN MEMBER_TY,
        OUT_MEMBER_ID OUT MEMBERS.MEMBER_ID%TYPE
    );
END MEMBER_PKG;
/

CREATE OR REPLACE PACKAGE BODY MEMBER_PKG AS

    FUNCTION GET_RANDOM_GROUP_LEADER_FUNC RETURN MEMBERS.MEMBER_ID%TYPE IS
        V_RESULT MEMBERS.MEMBER_ID%TYPE;
    BEGIN
        SELECT T2.MEMBER_ID INTO V_RESULT
        FROM (
                SELECT T1.*
                FROM (
                        SELECT *
                        FROM MEMBERS
                        WHERE RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC (
                                P_MEMBER_ID => MEMBERS.MEMBER_ID /*IN NUMBER*/,
                                P_RANK_NAME => CONSTANTS_PKG.RANKS_NAMES ( 'GL' ) /*IN VARCHAR2*/
                            ) = 1 AND
                            ROWNUM = 1
                    ) T1
                ORDER BY DBMS_RANDOM.VALUE
            ) T2;
        IF V_RESULT IS NOT NULL THEN
            RETURN V_RESULT;
        ELSE
            RETURN NULL;
        END IF;
    END GET_RANDOM_GROUP_LEADER_FUNC;

    FUNCTION GET_RANDOM_PATROL_LEADER_FUNC RETURN MEMBERS.MEMBER_ID%TYPE IS
        V_RESULT MEMBERS.MEMBER_ID%TYPE;
    BEGIN
        SELECT T2.MEMBER_ID INTO V_RESULT
        FROM (
                SELECT T1.*
                FROM (
                        SELECT *
                        FROM MEMBERS
                        WHERE RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC (
                                P_MEMBER_ID => MEMBERS.MEMBER_ID /*IN NUMBER*/,
                                P_RANK_NAME => 'PATROL_LEADER' /*IN VARCHAR2*/
                            ) = 1 AND
                            ROWNUM = 1
                    ) T1
                ORDER BY DBMS_RANDOM.VALUE
            ) T2;
        IF V_RESULT IS NOT NULL THEN
            RETURN V_RESULT;
        ELSE
            RETURN NULL;
        END IF;
    END GET_RANDOM_PATROL_LEADER_FUNC;

    PROCEDURE CREATE_MEMBER (
        P_MEMBER IN MEMBER_TY
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        IF P_MEMBER.FIRST_NAME IS NULL OR P_MEMBER.LAST_NAME IS NULL OR P_MEMBER.MOTHERS_NAME IS NULL OR P_MEMBER.MOTHERS_TELEPHONE_NUMBER IS NULL OR P_MEMBER.MOTHERS_EMAIL IS NULL THEN
            RAISE EXCEPTIONS_PKG.MISSING_PARAM_EXC;
        ELSE
            INSERT INTO MEMBERS (
                FIRST_NAME,
                LAST_NAME,
                MOTHERS_NAME,
                MOTHERS_TELEPHONE_NUMBER,
                MOTHERS_EMAIL,
                MEMBER_EMAIL,
                MEMBER_TELEPHONE_NUMBER,
                BIRTH_DATE,
                ORS_ID,
                PATROL_ID
            ) VALUES (
                P_MEMBER.FIRST_NAME,
                P_MEMBER.LAST_NAME,
                P_MEMBER.MOTHERS_NAME,
                P_MEMBER.MOTHERS_TELEPHONE_NUMBER,
                P_MEMBER.MOTHERS_EMAIL,
                P_MEMBER.MEMBER_EMAIL,
                P_MEMBER.MEMBER_TELEPHONE_NUMBER,
                P_MEMBER.BIRTH_DATE,
                CASE WHEN P_MEMBER.ORS_ID IS NOT NULL THEN NULL WHEN P_MEMBER.ORS_ID IN ( SELECT ORS_ID FROM ORS ) THEN P_MEMBER.ORS_ID END,
                P_MEMBER.PATROL_ID
            );
            COMMIT;
        END IF;
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR ( -20009, 'There is already a Member like that' );
        WHEN EXCEPTIONS_PKG.MISSING_PARAM_EXC THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'Missing required information about member' );
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR ( -20011, 'CODE- '|| SQLCODE || 'MESSAGE- ' || SQLERRM );
    END CREATE_MEMBER;

    PROCEDURE CREATE_MEMBER_FOR_USER (
        P_MEMBER IN MEMBER_TY,
        OUT_MEMBER_ID OUT MEMBERS.MEMBER_ID%TYPE
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        OUT_MEMBER_ID := MEMBERS_SEQ.NEXTVAL;
        IF ( P_MEMBER.FIRST_NAME IS NULL OR
        P_MEMBER.LAST_NAME IS NULL OR
        P_MEMBER.MOTHERS_NAME IS NULL OR
        P_MEMBER.MOTHERS_TELEPHONE_NUMBER IS NULL OR
        P_MEMBER.MOTHERS_EMAIL IS NULL ) THEN
            RAISE EXCEPTIONS_PKG.MISSING_PARAM_EXC;
        ELSE
            INSERT INTO MEMBERS (
                MEMBER_ID,
                FIRST_NAME,
                LAST_NAME,
                MOTHERS_NAME,
                MOTHERS_TELEPHONE_NUMBER,
                MOTHERS_EMAIL,
                MEMBER_EMAIL,
                MEMBER_TELEPHONE_NUMBER,
                BIRTH_DATE,
                ORS_ID,
                PATROL_ID
            ) VALUES (
                OUT_MEMBER_ID,
                P_MEMBER.FIRST_NAME,
                P_MEMBER.LAST_NAME,
                P_MEMBER.MOTHERS_NAME,
                P_MEMBER.MOTHERS_TELEPHONE_NUMBER,
                P_MEMBER.MOTHERS_EMAIL,
                P_MEMBER.MEMBER_EMAIL,
                P_MEMBER.MEMBER_TELEPHONE_NUMBER,
                P_MEMBER.BIRTH_DATE,
                CASE WHEN P_MEMBER.ORS_ID IS NOT NULL THEN NULL WHEN P_MEMBER.ORS_ID IN ( SELECT ORS_ID FROM ORS ) THEN P_MEMBER.ORS_ID END,
                P_MEMBER.PATROL_ID
            );
        END IF;

        COMMIT;
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR ( -20009, 'There is already a Member like that' );
        WHEN EXCEPTIONS_PKG.MISSING_PARAM_EXC THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'Missing required information about member' );
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR ( -20011, 'CODE- '|| SQLCODE || 'MESSAGE- ' || SQLERRM );
    END CREATE_MEMBER_FOR_USER;
END MEMBER_PKG;
/

--PACKEGES/MEETINGS.PCK
CREATE OR REPLACE PACKAGE MEETING_PKG AS

    PROCEDURE NEW_MEETING_FROM_XML (
        P_MEETING_XML CLOB
    );

    PROCEDURE EDIT_MEETING_CONTENT_BY_ID (
        P_MEETING_ID NUMBER,
        P_NEW_CONTENT CLOB
    );

    PROCEDURE DELETE_MEETING_BY_ID (
        P_MEETING_ID NUMBER
    );

    FUNCTION GET_MEETING_BY_ID (
        P_MEETING_ID NUMBER
    ) RETURN MEETING%ROWTYPE;

    PROCEDURE GET_MEETINGS_BY_AUTHOR (
        P_AUTHOR_ID NUMBER,
        P_MEETINGS OUT T_MEETING_TY
    );

    PROCEDURE GET_MEETINGS_BY_EVENT (
        P_EVENT_ID NUMBER,
        P_MEETINGS OUT T_MEETING_TY
    );

    FUNCTION GET_MEETINGS_BETWEEN (
        P_START_DATE IN DATE,
        P_END_DATE IN DATE
    ) RETURN T_MEETING_TY;
END MEETING_PKG;
/

CREATE OR REPLACE PACKAGE BODY MEETING_PKG AS
 
    -- New meeting from xml
    PROCEDURE NEW_MEETING_FROM_XML (
        P_MEETING_XML CLOB
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
        V_MEETING_CONTENT CLOB;
        V_AUTHOR_ID       NUMBER;
        V_EVENT_ID        NUMBER;
    BEGIN
        SELECT EXTRACTVALUE ( XMLTYPE ( P_MEETING_XML ) , '/meeting/content' ),
            EXTRACTVALUE ( XMLTYPE ( P_MEETING_XML ) , '/meeting/author_id' ),
            EXTRACTVALUE ( XMLTYPE ( P_MEETING_XML ) , '/meeting/event_id' ) INTO V_MEETING_CONTENT,
            V_AUTHOR_ID,
            V_EVENT_ID
        FROM DUAL;
        IF V_MEETING_CONTENT IS NULL OR V_AUTHOR_ID IS NULL OR V_EVENT_ID IS NULL THEN
            RAISE EXCEPTIONS_PKG.INVALID_FORMAT_EXC;
        END IF;

        INSERT INTO MEETING (
            MEETING_CONTENT,
            AUTHOR_ID,
            EVENT_ID
        ) VALUES (
            V_MEETING_CONTENT,
            V_AUTHOR_ID,
            V_EVENT_ID
        );
        COMMIT;
    EXCEPTION
        WHEN EXCEPTIONS_PKG.INVALID_FORMAT_EXC THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'Invalid format, file must contain meeting content, author, and event' );
            DBMS_OUTPUT.PUT_LINE ( ' Invalid XML: ' || P_MEETING_XML );
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END NEW_MEETING_FROM_XML;
 

    -- Edit meeting content by id
    PROCEDURE EDIT_MEETING_CONTENT_BY_ID (
        P_MEETING_ID NUMBER,
        P_NEW_CONTENT CLOB
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        UPDATE MEETING
        SET
            MEETING_CONTENT = P_NEW_CONTENT
        WHERE
            MEETING_ID = P_MEETING_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR ( -21000, 'Meeting ID not found' );
        END IF;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END EDIT_MEETING_CONTENT_BY_ID;
 

    -- Delete meeting by id
    PROCEDURE DELETE_MEETING_BY_ID (
        P_MEETING_ID NUMBER
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        DELETE FROM MEETING
        WHERE
            MEETING_ID = P_MEETING_ID;
        IF SQL%ROWCOUNT = 0 THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR ( -21000, 'Meeting ID not found' );
        END IF;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END DELETE_MEETING_BY_ID;
 

    -- Get meeting by id
    FUNCTION GET_MEETING_BY_ID (
        P_MEETING_ID NUMBER
    ) RETURN MEETING%ROWTYPE IS
        V_MEETING MEETING%ROWTYPE;
    BEGIN
        SELECT * INTO V_MEETING
        FROM MEETING
        WHERE MEETING_ID = P_MEETING_ID;
        RETURN V_MEETING;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error on GET_MEETING_BY_ID - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END GET_MEETING_BY_ID;

    PROCEDURE GET_MEETINGS_BY_AUTHOR (
        P_AUTHOR_ID NUMBER,
        P_MEETINGS OUT T_MEETING_TY
    ) AS
    BEGIN
        SELECT R_MEETING_TY ( MEETING_ID, MEETING_CONTENT, AUTHOR_ID, EVENT_ID, CREATED_AT ) BULK COLLECT INTO P_MEETINGS
        FROM MEETING
        WHERE AUTHOR_ID = P_AUTHOR_ID;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No meeting found on-' || P_AUTHOR_ID ||'- AUTHOR_ID ' ||'- ' || SQLCODE || ' -ERROR- ' || SQLERRM );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END GET_MEETINGS_BY_AUTHOR;

    PROCEDURE GET_MEETINGS_BY_EVENT (
        P_EVENT_ID NUMBER,
        P_MEETINGS OUT T_MEETING_TY
    ) AS
    BEGIN
        SELECT R_MEETING_TY ( MEETING_ID, MEETING_CONTENT, AUTHOR_ID, EVENT_ID, CREATED_AT ) BULK COLLECT INTO P_MEETINGS
        FROM MEETING
        WHERE EVENT_ID = P_EVENT_ID;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No meeting found on-' || P_EVENT_ID ||'- EVENT_ID ' ||'- ' || SQLCODE || ' -ERROR- ' || SQLERRM );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END GET_MEETINGS_BY_EVENT;

    FUNCTION GET_MEETINGS_BETWEEN (
        P_START_DATE IN DATE,
        P_END_DATE IN DATE
    ) RETURN T_MEETING_TY AS
        V_RESULT T_MEETING_TY;
    BEGIN
        CASE
            WHEN P_START_DATE < P_END_DATE THEN
                SELECT R_MEETING_TY ( MEETING_ID, MEETING_CONTENT, AUTHOR_ID, EVENT_ID, CREATED_AT ) BULK COLLECT INTO V_RESULT
                FROM MEETING
                WHERE CREATED_AT BETWEEN P_START_DATE AND P_END_DATE;
            WHEN P_START_DATE > P_END_DATE THEN
                SELECT R_MEETING_TY ( MEETING_ID, MEETING_CONTENT, AUTHOR_ID, EVENT_ID, CREATED_AT ) BULK COLLECT INTO V_RESULT
                FROM MEETING
                WHERE CREATED_AT BETWEEN P_END_DATE AND P_START_DATE;
        END CASE;

        IF V_RESULT IS NULL THEN
            RAISE NO_DATA_FOUND;
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No meeting found BETWEEN- ' || P_START_DATE ||' - and -' || P_END_DATE ||' - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END GET_MEETINGS_BETWEEN;
END MEETING_PKG;
/

--PACKEGES/ORS.PCK
CREATE OR REPLACE PACKAGE ORS_PKG AS

    FUNCTION GET_RANDOM_ORS_FUNC RETURN ORS.ORS_ID%TYPE;

    FUNCTION GET_ORS_BY_ID_FUNC (
        P_ORS_ID ORS.ORS_ID%TYPE
    ) RETURN ORS.ORS_NAME%TYPE;

    FUNCTION GET_ORS_BY_NAME_FUNC (
        P_ORS_NAME ORS.ORS_NAME%TYPE
    ) RETURN ORS.ORS_ID%TYPE;

    PROCEDURE CREATE_ORS (
        P_NAME IN VARCHAR2,
        P_PATROL_ID IN NUMBER,
        P_LEADER_ID IN NUMBER
    );

    PROCEDURE CREATE_ORS (
        P_NAME IN VARCHAR2,
        P_PATROL_ID IN NUMBER
    );

    PROCEDURE ASSIGN_LEADER_TO_GROUP (
        P_LEADER_ID IN NUMBER,
        P_GROUP_ID IN NUMBER
    );
END ORS_PKG;
/

CREATE OR REPLACE PACKAGE BODY ORS_PKG AS

    FUNCTION GET_RANDOM_ORS_FUNC RETURN ORS.ORS_ID%TYPE IS
        V_RESULT ORS.ORS_ID%TYPE;
    BEGIN
        SELECT ORS_ID INTO V_RESULT
        FROM ORS
        WHERE ROWNUM = 1
        ORDER BY DBMS_RANDOM.VALUE;
        RETURN V_RESULT;
    END GET_RANDOM_ORS_FUNC;

    FUNCTION GET_ORS_BY_ID_FUNC (
        P_ORS_ID ORS.ORS_ID%TYPE
    ) RETURN ORS.ORS_NAME%TYPE IS
        V_RESULT ORS.ORS_NAME%TYPE;
    BEGIN
        SELECT ORS_NAME INTO V_RESULT
        FROM ORS
        WHERE ORS_ID = P_ORS_ID;
        CASE NVL ( V_RESULT, 0 )
            WHEN 0 THEN
                RAISE EXCEPTIONS_PKG.NOT_FOUND_ORS_EXC;
            ELSE
                RETURN V_RESULT;
        END CASE;
    EXCEPTION
        WHEN EXCEPTIONS_PKG.NOT_FOUND_ORS_EXC THEN
            DBMS_OUTPUT.PUT_LINE ( 'Ors ID does not found - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END GET_ORS_BY_ID_FUNC;

    FUNCTION GET_ORS_BY_NAME_FUNC (
        P_ORS_NAME ORS.ORS_NAME%TYPE
    ) RETURN ORS.ORS_ID%TYPE IS
        V_RESULT ORS.ORS_ID%TYPE;
    BEGIN
        SELECT ORS_ID INTO V_RESULT
        FROM ORS
        WHERE ORS_NAME = P_ORS_NAME;
        CASE NVL ( V_RESULT, 0 )
            WHEN 0 THEN
                RAISE EXCEPTIONS_PKG.NOT_FOUND_ORS_EXC;
            ELSE
                RETURN V_RESULT;
        END CASE;
    EXCEPTION
        WHEN EXCEPTIONS_PKG.NOT_FOUND_ORS_EXC THEN
            DBMS_OUTPUT.PUT_LINE ( 'Ors ID does not found - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
        WHEN TOO_MANY_ROWS THEN
            DBMS_OUTPUT.PUT_LINE ( 'Too many rows found - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END GET_ORS_BY_NAME_FUNC;

    PROCEDURE CREATE_ORS (
        P_NAME IN VARCHAR2,
        P_PATROL_ID IN NUMBER,
        P_LEADER_ID IN NUMBER
    ) IS
    BEGIN
        INSERT INTO ORS (
            ORS_NAME,
            PATROL_ID,
            LEADER_ID
        ) VALUES (
            P_NAME,
            P_PATROL_ID,
            P_LEADER_ID
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR ( -20009, 'There is already an '|| P_NAME || ' Group' );
    END CREATE_ORS;

    PROCEDURE CREATE_ORS (
        P_NAME IN VARCHAR2,
        P_PATROL_ID IN NUMBER
    ) IS
        V_LEADER_ID NUMBER;
    BEGIN
        V_LEADER_ID := MEMBER_PKG.GET_RANDOM_GROUP_LEADER_FUNC ( );
        IF V_LEADER_ID IS NULL THEN
            INSERT INTO ORS (
                ORS_NAME,
                PATROL_ID
            ) VALUES (
                P_NAME,
                P_PATROL_ID
            );
        ELSE
            INSERT INTO ORS (
                ORS_NAME,
                PATROL_ID,
                LEADER_ID
            ) VALUES (
                P_NAME,
                P_PATROL_ID,
                V_LEADER_ID
            );
        END IF;
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR ( -20009, 'There is already an '|| P_NAME || ' Group' );
    END CREATE_ORS;

    PROCEDURE ASSIGN_LEADER_TO_GROUP (
        P_LEADER_ID IN NUMBER,
        P_GROUP_ID IN NUMBER
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
        V_GROUP_EXISTS NUMBER;
    BEGIN
        SELECT 1 INTO V_GROUP_EXISTS
        FROM ORS
        WHERE ORS_ID = P_GROUP_ID;
        IF V_GROUP_EXISTS > 0 THEN
            UPDATE ORS
            SET
                LEADER_ID = P_LEADER_ID
            WHERE
                ORS_ID = P_GROUP_ID;
            COMMIT;
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No such group/ors found: ' || P_GROUP_ID );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
            ROLLBACK;
    END ASSIGN_LEADER_TO_GROUP;
END ORS_PKG;
/

--PACKEGES/PATROL.PCK
CREATE OR REPLACE PACKAGE PATROL_PKG AS

    PROCEDURE CREATE_PATROL (
        P_NAME IN VARCHAR2,
        P_LEADER_ID IN NUMBER
    );

    PROCEDURE CREATE_PATROL (
        P_NAME IN VARCHAR2
    );

    PROCEDURE ASSIGN_LEADER_TO_PATROL (
        P_LEADER_ID IN NUMBER,
        P_PATROL_ID IN NUMBER
    );
END PATROL_PKG;
/

CREATE OR REPLACE PACKAGE BODY PATROL_PKG AS

    PROCEDURE CREATE_PATROL (
        P_NAME IN VARCHAR2,
        P_LEADER_ID IN NUMBER
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO PATROL (
            PATROL_NAME,
            LEADER_ID
        ) VALUES (
            P_NAME,
            P_LEADER_ID
        );
        COMMIT;
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR ( -20009, 'There is already an '|| P_NAME || ' Patrol' );
    END CREATE_PATROL;

    PROCEDURE CREATE_PATROL (
        P_NAME IN VARCHAR2
    ) IS
    BEGIN
        INSERT INTO PATROL (
            PATROL_NAME
        ) VALUES (
            P_NAME
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR ( -20009, 'There is already an '|| P_NAME || ' Patrol' );
    END CREATE_PATROL;

    PROCEDURE ASSIGN_LEADER_TO_PATROL (
        P_LEADER_ID IN NUMBER,
        P_PATROL_ID IN NUMBER
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
        V_PATROL_EXISTS NUMBER;
    BEGIN
        SELECT 1 INTO V_PATROL_EXISTS
        FROM PATROL
        WHERE PATROL_ID = P_PATROL_ID;
        IF V_PATROL_EXISTS > 0 THEN
            UPDATE PATROL
            SET
                LEADER_ID = P_LEADER_ID
            WHERE
                PATROL_ID = P_PATROL_ID;
            COMMIT;
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No such patrol/raj found: ' || P_PATROL_ID );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
            ROLLBACK;
    END ASSIGN_LEADER_TO_PATROL;
END PATROL_PKG;
/

--PACKEGES/RANK_PRIVILEGES.PCK
CREATE OR REPLACE PACKAGE RANK_PRIVILEGES_PGK IS

    PROCEDURE PROMOTE_MEMBER (
        P_MEMBER_ID IN NUMBER,
        P_RANK_ID IN NUMBER
    );

    PROCEDURE DEPROMOTE_MEMBER (
        P_MEMBER_ID IN NUMBER,
        P_RANK_ID IN NUMBER
    );

    PROCEDURE LEADER_TO_GROUP (
        P_LEADER_ID IN NUMBER
    );

    PROCEDURE VALIDATE_PROMOTION_TIME;
END RANK_PRIVILEGES_PGK;
/

CREATE OR REPLACE PACKAGE BODY RANK_PRIVILEGES_PGK IS

    PROCEDURE PROMOTE_MEMBER (
        P_MEMBER_ID IN NUMBER,
        P_RANK_ID IN NUMBER
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO RANK_PRIVILEGES (
            MEMBER_ID,
            RANK_ID
        ) VALUES (
            P_MEMBER_ID,
            P_RANK_ID
        );
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'Error happend at the promotion of the -'|| P_MEMBER_ID || '- to: '||P_RANK_ID );
    END PROMOTE_MEMBER;

    PROCEDURE DEPROMOTE_MEMBER (
        P_MEMBER_ID IN NUMBER,
        P_RANK_ID IN NUMBER
    ) IS
    BEGIN
        DELETE FROM RANK_PRIVILEGES
        WHERE
            MEMBER_ID = P_MEMBER_ID AND
            RANK_ID = P_RANK_ID;
    END DEPROMOTE_MEMBER;

    PROCEDURE LEADER_TO_GROUP (
        P_LEADER_ID IN NUMBER
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
        V_LEADER_IN NUMBER;
        V_IS_LEADER NUMBER;
    BEGIN
        V_IS_LEADER := RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC ( P_MEMBER_ID => P_LEADER_ID /*IN NUMBER*/, P_RANK_NAME => 'GROUP_LEADER' /*IN VARCHAR2*/ );
        CASE V_IS_LEADER
            WHEN 1 THEN
                SELECT ORS_ID INTO V_LEADER_IN
                FROM GROUP_LEADERS_VW
                WHERE P_LEADER_ID = LEADER_ID AND
                    ROWNUM = 1;
                IF V_LEADER_IN IS NOT NULL THEN
                    UPDATE MEMBERS M
                    SET
                        M.ORS_ID = V_LEADER_IN
                    WHERE
                        MEMBER_ID = P_LEADER_ID;
                END IF;
                COMMIT;
            ELSE
                RAISE EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC;
        END CASE;
    EXCEPTION
        WHEN EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'The member ( '|| P_LEADER_ID || ' ) have not group leader rank' );
    END LEADER_TO_GROUP;

    PROCEDURE VALIDATE_PROMOTION_TIME AS
    BEGIN
        DELETE RANK_PRIVILEGES
        WHERE
            PROMOTION_TIME_END >= SYSTIMESTAMP;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'Error has happend at validating promotions' );
    END VALIDATE_PROMOTION_TIME;
END RANK_PRIVILEGES_PGK;
/

--PACKEGES/USER_FACTORY.PCK
CREATE OR REPLACE PACKAGE USER_FACTORY_PKG IS

    PROCEDURE CREATE_GROUP_LEADER_PR (
        P_MEMBER IN MEMBER_TY
    );
END USER_FACTORY_PKG;
/

CREATE OR REPLACE PACKAGE BODY USER_FACTORY_PKG IS

    PROCEDURE CREATE_LEADER_USER (
        P_LAST_NAME IN VARCHAR2,
        P_PASSWORD IN VARCHAR2
    ) AS
    BEGIN
        EXECUTE IMMEDIATE 'CREATE USER ' || P_LAST_NAME || '_LEADER IDENTIFIED BY ' || P_PASSWORD || ' DEFAULT TABLESPACE USER QUOTA UNLIMITED ON USER';
        EXECUTE IMMEDIATE 'GRANT CREATE SESSION TO ' || P_LAST_NAME || '_LEADER';
        EXECUTE IMMEDIATE 'GRANT SELECT ON ORS, EVENTS, EVENT_DUTIES_ASS, DUTIES, KNOWLEDGE, KNOWLEDGE_MEDIA_ASS, MEDIA TO ' || P_LAST_NAME || '_LEADER';
        EXECUTE IMMEDIATE 'GRANT UPDATE ON MEMBERS TO ' || P_LAST_NAME || '_LEADER';
        DBMS_OUTPUT.PUT_LINE ( 'USER CREATED' || P_LAST_NAME || '_LEADER' );
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'ERROR OCCURD AT USER CREATION' || SQLCODE || ' - ' || SQLERRM );
    END CREATE_LEADER_USER;

    PROCEDURE CREATE_GROUP_LEADER_PR (
        P_MEMBER IN MEMBER_TY
    ) AS
        V_LEADER_ID        NUMBER;
        V_LEADER_LAST_NAME MEMBERS.LAST_NAME%TYPE;
        V_GL_ID            RANK_DICTIONARY.RANK_ID%TYPE;
        V_ERRM             VARCHAR2 ( 200 );
        V_CODE             VARCHAR2 ( 200 );
    BEGIN
        MEMBER_PKG.CREATE_MEMBER_FOR_USER (
            P_MEMBER => P_MEMBER /*IN MEMBER_TY*/,
            OUT_MEMBER_ID => V_LEADER_ID /*OUT NUMBER*/
        );
        SELECT RANK_ID INTO V_GL_ID
        FROM RANK_DICTIONARY
        WHERE RANK_NAME = CONSTANTS_PKG.RANKS_NAMES ( 'GL' );
        IF V_GL_ID IS NULL THEN
            RAISE_APPLICATION_ERROR ( -20022, 'There is no a GROUP_LEADER rank in RANK_DICTIONARY!' );
        END IF;

        RANK_PRIVILEGES_PGK.PROMOTE_MEMBER (
            P_MEMBER_ID => V_LEADER_ID /*IN NUMBER*/,
            P_RANK_ID => V_GL_ID /*IN NUMBER*/
        );
        SELECT LAST_NAME INTO V_LEADER_LAST_NAME
        FROM MEMBERS
        WHERE MEMBER_ID = V_LEADER_ID;
        IF RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC (
            P_MEMBER_ID => V_LEADER_ID /*IN NUMBER*/,
            P_RANK_NAME => CONSTANTS_PKG.RANKS_NAMES ( 'GL' ) /*IN VARCHAR2*/
        ) = 1 THEN
            CREATE_LEADER_USER ( V_LEADER_LAST_NAME, '123' );
        END IF;
    EXCEPTION
        WHEN EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC THEN
            DBMS_OUTPUT.PUT_LINE ( 'ERROR- Insufficient priveleges/rank to create user' );
            V_ERRM := SQLERRM;
            V_CODE := SQLCODE;
            INSERT INTO PERSONAL_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'FAILED USER CREATION AT- '|| SYSTIMESTAMP || ' -' || V_CODE|| ' - ' ||V_ERRM,
                'MEMBERS',
                'CREATE USER'
            );
            COMMIT;
        WHEN OTHERS THEN
            V_ERRM := SQLERRM;
            V_CODE := SQLCODE;
            INSERT INTO PERSONAL_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'FAILED USER CREATION AT- '|| SYSTIMESTAMP || ' -' ||V_CODE || ' - ' ||V_ERRM,
                'MEMBERS',
                'CREATE USER'
            );
            COMMIT;
    END CREATE_GROUP_LEADER_PR;
END USER_FACTORY_PKG;
/

--PACKEGES/ADDRESS.PCK
CREATE OR REPLACE PACKAGE ADDRESS_PKG AS

    PROCEDURE CREATE_ADDRESS (
        P_ZIP_CODE IN VARCHAR2,
        P_COUNTRY IN VARCHAR2,
        P_CITY IN VARCHAR2,
        P_STREET_NAME IN VARCHAR2,
        P_STREET_TYPE IN VARCHAR2,
        P_HOUSE_NUMBER IN VARCHAR2
    );

    PROCEDURE CREATE_ADDRESS (
        P_ADDRESS IN ADDRESS%ROWTYPE
    );

    FUNCTION GET_ADDRESS_BY_ID (
        P_ADDRESS_ID IN NUMBER
    ) RETURN ADDRESS%ROWTYPE;

    FUNCTION GET_ADDRESS_BY_RESIDENT (
        P_MEMBER_ID IN NUMBER
    ) RETURN ADDRESS%ROWTYPE;

    PROCEDURE UPDATE_ADDRESS (
        P_ADDRESS_ID IN NUMBER,
        P_ZIP_CODE IN VARCHAR2,
        P_COUNTRY IN VARCHAR2,
        P_CITY IN VARCHAR2,
        P_STREET_NAME IN VARCHAR2,
        P_STREET_TYPE IN VARCHAR2,
        P_HOUSE_NUMBER IN VARCHAR2
    );

    PROCEDURE DELETE_ADDRESS (
        P_ADDRESS_ID IN NUMBER
    );

    PROCEDURE ASSIGN_MEMBER_TO_ADDRESS (
        P_MEMBER_ID IN NUMBER,
        P_ADDRESS_ID IN NUMBER
    );
END ADDRESS_PKG;
/

CREATE OR REPLACE PACKAGE BODY ADDRESS_PKG AS

    FUNCTION ADDRESS_DUPLICATE_FINDER_FN (
        P_ADDRESS IN ADDRESS_TY
    ) RETURN NUMBER IS
        PRAGMA AUTONOMOUS_TRANSACTION;
        V_RETURN_ID NUMBER;
    BEGIN
        SELECT ADDRESS_ID INTO V_RETURN_ID
        FROM ADDRESS
        WHERE 1=1 AND
            TRIM ( UPPER ( ZIP_CODE ) ) = TRIM ( UPPER ( P_ADDRESS.ZIP_CODE ) ) AND
            TRIM ( UPPER ( COUNTRY ) ) = TRIM ( UPPER ( P_ADDRESS.COUNTRY ) ) AND
            TRIM ( UPPER ( CITY ) ) = TRIM ( UPPER ( P_ADDRESS.CITY ) ) AND
            TRIM ( UPPER ( STREET_NAME ) ) = TRIM ( UPPER ( P_ADDRESS.STREET_NAME ) ) AND
            TRIM ( UPPER ( STREET_TYPE ) ) = TRIM ( UPPER ( P_ADDRESS.STREET_TYPE ) ) AND
            TRIM ( UPPER ( HOUSE_NUMBER ) ) = TRIM ( UPPER ( P_ADDRESS.HOUSE_NUMBER ) );
        RETURN V_RETURN_ID;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 0;
            DBMS_OUTPUT.PUT_LINE ( 'No rows inserted.' );
        WHEN OTHERS THEN
            RETURN 0;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END ADDRESS_DUPLICATE_FINDER_FN;

    PROCEDURE CREATE_ADDRESS (
        P_ZIP_CODE IN VARCHAR2,
        P_COUNTRY IN VARCHAR2,
        P_CITY IN VARCHAR2,
        P_STREET_NAME IN VARCHAR2,
        P_STREET_TYPE IN VARCHAR2,
        P_HOUSE_NUMBER IN VARCHAR2
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
        V_RESULT  NUMBER;
        V_ADDRESS ADDRESS_TY;
    BEGIN
        V_ADDRESS := ADDRESS_TY ( P_ZIP_CODE, P_COUNTRY, P_CITY, P_STREET_NAME, P_STREET_TYPE, P_HOUSE_NUMBER );
        V_RESULT := ADDRESS_DUPLICATE_FINDER_FN ( P_ADDRESS => V_ADDRESS );
        IF V_RESULT = 0 THEN
            INSERT INTO ADDRESS (
                ZIP_CODE,
                COUNTRY,
                CITY,
                STREET_NAME,
                STREET_TYPE,
                HOUSE_NUMBER
            ) VALUES (
                P_ZIP_CODE,
                P_COUNTRY,
                P_CITY,
                P_STREET_NAME,
                P_STREET_TYPE,
                P_HOUSE_NUMBER
            );
            COMMIT;
        ELSE
            DBMS_OUTPUT.PUT_LINE ( 'Address already exists with ID: ' || V_RESULT );
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END CREATE_ADDRESS;

    PROCEDURE CREATE_ADDRESS (
        P_ADDRESS IN ADDRESS%ROWTYPE
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
        V_RESULT  ADDRESS.ADDRESS_ID%TYPE;
        V_ADDRESS ADDRESS_TY;
    BEGIN
        V_ADDRESS := ADDRESS_TY ( P_ADDRESS.ZIP_CODE, P_ADDRESS.COUNTRY, P_ADDRESS.CITY, P_ADDRESS.STREET_NAME, P_ADDRESS.STREET_TYPE, P_ADDRESS.HOUSE_NUMBER );
        V_RESULT := ADDRESS_DUPLICATE_FINDER_FN ( P_ADDRESS => V_ADDRESS );
        IF V_RESULT = 0 THEN
            INSERT INTO ADDRESS (
                ZIP_CODE,
                COUNTRY,
                CITY,
                STREET_NAME,
                STREET_TYPE,
                HOUSE_NUMBER
            ) VALUES (
                P_ADDRESS.ZIP_CODE,
                P_ADDRESS.COUNTRY,
                P_ADDRESS.CITY,
                P_ADDRESS.STREET_NAME,
                P_ADDRESS.STREET_TYPE,
                P_ADDRESS.HOUSE_NUMBER
            );
            COMMIT;
        ELSE
            DBMS_OUTPUT.PUT_LINE ( 'Address already exists with ID: ' || V_RESULT );
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
            ROLLBACK;
    END CREATE_ADDRESS;

    FUNCTION GET_ADDRESS_BY_ID (
        P_ADDRESS_ID IN NUMBER
    ) RETURN ADDRESS%ROWTYPE AS
        V_ADDRESS ADDRESS%ROWTYPE;
    BEGIN
        SELECT * INTO V_ADDRESS
        FROM ADDRESS
        WHERE ADDRESS_ID = P_ADDRESS_ID;
        RETURN V_ADDRESS;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No rows found.' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END GET_ADDRESS_BY_ID;

    FUNCTION GET_ADDRESS_BY_RESIDENT (
        P_MEMBER_ID IN NUMBER
    ) RETURN ADDRESS%ROWTYPE AS
        V_ADDRESS ADDRESS%ROWTYPE;
    BEGIN
        SELECT * INTO V_ADDRESS
        FROM ADDRESS
        WHERE ADDRESS_ID IN (
                SELECT ADDRESS_ID
                FROM ADDRESS_MEMBER_ASS
                WHERE MEMBER_ID = P_MEMBER_ID
            );
        RETURN V_ADDRESS;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No rows found.' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END GET_ADDRESS_BY_RESIDENT;

    PROCEDURE UPDATE_ADDRESS (
        P_ADDRESS_ID IN NUMBER,
        P_ZIP_CODE IN VARCHAR2,
        P_COUNTRY IN VARCHAR2,
        P_CITY IN VARCHAR2,
        P_STREET_NAME IN VARCHAR2,
        P_STREET_TYPE IN VARCHAR2,
        P_HOUSE_NUMBER IN VARCHAR2
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        UPDATE ADDRESS
        SET
            ZIP_CODE = P_ZIP_CODE,
            COUNTRY = P_COUNTRY,
            CITY = P_CITY,
            STREET_NAME = P_STREET_NAME,
            STREET_TYPE = P_STREET_TYPE,
            HOUSE_NUMBER = P_HOUSE_NUMBER
        WHERE
            ADDRESS_ID = P_ADDRESS_ID;
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END UPDATE_ADDRESS;

    PROCEDURE DELETE_ADDRESS (
        P_ADDRESS_ID IN NUMBER
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        DELETE FROM ADDRESS
        WHERE
            ADDRESS_ID = P_ADDRESS_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR ( -20001, 'No address found with the given ID.' );
        END IF;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT .PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END DELETE_ADDRESS;

    PROCEDURE ASSIGN_MEMBER_TO_ADDRESS (
        P_MEMBER_ID IN NUMBER,
        P_ADDRESS_ID IN NUMBER
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO ADDRESS_MEMBER_ASS (
            ADDRESS_ID,
            MEMBER_ID
        ) VALUES (
            P_ADDRESS_ID,
            P_MEMBER_ID
        );
        COMMIT;
    END ASSIGN_MEMBER_TO_ADDRESS;
END ADDRESS_PKG;
/

--PACKEGES/GATHERING.PCK
CREATE OR REPLACE PACKAGE GATHERING_PKG IS

    PROCEDURE NEW_GATHERING_FROM_STRING (
        P_REPORT_STRING IN VARCHAR2,
        P_AUTHOR_ID IN GATHERING_REPORTS.AUTHOR_ID%TYPE,
        P_ORS_ID IN GATHERING_REPORTS.ORS_ID%TYPE
    );

    PROCEDURE NEW_GATHER_REPORT_FROM_BFILE (
        P_FILE_NAME VARCHAR2
    );

    PROCEDURE UPDATE_REPORT_CONTENT (
        P_REPORT_ID IN GATHERING_REPORTS.REPORT_ID%TYPE,
        P_CONTENT IN GATHERING_REPORTS.REPORT_CONTENT%TYPE
    );

    FUNCTION GET_REPORT_BY_ID (
        P_REPORT_ID IN GATHERING_REPORTS.REPORT_ID%TYPE
    ) RETURN R_GATHERING_REPORT_TY;

    FUNCTION GET_ALL_REPORTS RETURN T_GATHERING_REPORT_TY;

    FUNCTION GET_AUTHOR_REPORTS_FN (
        P_AUTHOR_ID GATHERING_REPORTS.AUTHOR_ID%TYPE
    ) RETURN T_GATHERING_REPORT_TY;

    FUNCTION GET_AUTHOR_LATEST_REPORT (
        P_AUTHOR_ID GATHERING_REPORTS.AUTHOR_ID%TYPE
    ) RETURN R_GATHERING_REPORT_TY;

    FUNCTION GET_ORS_REPORTS (
        P_ORS_ID GATHERING_REPORTS.ORS_ID%TYPE
    ) RETURN T_GATHERING_REPORT_TY;

    FUNCTION GET_ORS_REPORTS (
        P_ORS_NAME ORS.ORS_NAME%TYPE
    ) RETURN T_GATHERING_REPORT_TY;
END GATHERING_PKG;
/

CREATE OR REPLACE PACKAGE BODY GATHERING_PKG IS

    PROCEDURE NEW_GATHERING_FROM_STRING (
        P_REPORT_STRING IN VARCHAR2,
        P_AUTHOR_ID IN GATHERING_REPORTS.AUTHOR_ID%TYPE,
        P_ORS_ID IN GATHERING_REPORTS.ORS_ID%TYPE
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        IF RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC (
            P_MEMBER_ID => P_AUTHOR_ID,
            P_RANK_NAME => CONSTANTS_PKG.RANKS_NAMES ( 'GL' )
        ) = 1 THEN
            INSERT INTO GATHERING_REPORTS (
                REPORT_CONTENT,
                AUTHOR_ID,
                ORS_ID
            ) VALUES (
                P_REPORT_STRING,
                P_AUTHOR_ID,
                P_ORS_ID
            );
            COMMIT;
        ELSE
            ROLLBACK;
            RAISE EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC;
        END IF;
    EXCEPTION
        WHEN EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC THEN
            INSERT INTO REPORT_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'User ' || USER || P_AUTHOR_ID ||' tried to insert a gathering report without the required privilege.',
                'GATHERING_REPORTS',
                'INSERT'
            );
            COMMIT;
    END;

    PROCEDURE NEW_GATHER_REPORT_FROM_BFILE (
        P_FILE_NAME VARCHAR2
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
        V_CLOB      CLOB;
        V_BFILE     BFILE;
        V_LEADER_ID MEMBERS.MEMBER_ID%TYPE;
    BEGIN
        V_LEADER_ID := MEMBER_PKG.GET_RANDOM_GROUP_LEADER_FUNC ( );
        V_BFILE := BFILENAME ( 'FILES_FOR_REPORT', LOWER ( P_FILE_NAME ) );
        DBMS_LOB.FILEOPEN ( V_BFILE );
        DBMS_LOB.LOADFROMFILE ( V_CLOB, V_BFILE, DBMS_LOB.GETLENGTH ( V_BFILE ) );
        DBMS_LOB.FILECLOSE ( V_BFILE );
        IF RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC (
            P_MEMBER_ID => V_LEADER_ID,
            P_RANK_NAME => CONSTANTS_PKG.RANKS_NAMES ( 'GL' )
        ) = 1 THEN
            INSERT INTO GATHERING_REPORTS (
                REPORT_CONTENT,
                AUTHOR_ID,
                ORS_ID
            ) VALUES (
                V_CLOB,
                V_LEADER_ID,
                ORS_PKG.GET_RANDOM_ORS_FUNC ( )
            );
            COMMIT;
        ELSE
            ROLLBACK;
            RAISE EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC;
        END IF;
    EXCEPTION
        WHEN EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC THEN
            INSERT INTO REPORT_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'User ' || USER || V_LEADER_ID ||' tried to insert a gathering report without the required privilege.',
                'GATHERING_REPORTS',
                'INSERT'
            );
            COMMIT;
    END;

    PROCEDURE UPDATE_REPORT_CONTENT (
        P_REPORT_ID IN GATHERING_REPORTS.REPORT_ID%TYPE,
        P_CONTENT IN GATHERING_REPORTS.REPORT_CONTENT%TYPE
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
        V_OLD_CONTENT GATHERING_REPORTS.REPORT_CONTENT%TYPE;
    BEGIN
        SELECT REPORT_CONTENT INTO V_OLD_CONTENT
        FROM GATHERING_REPORTS
        WHERE P_REPORT_ID = REPORT_ID;
        IF V_OLD_CONTENT = P_CONTENT THEN
            DBMS_OUTPUT.PUT_LINE ( 'The input content is identical with the old content' );
        ELSE
            UPDATE GATHERING_REPORTS
            SET
                REPORT_CONTENT = P_CONTENT
            WHERE
                REPORT_ID = P_REPORT_ID;
            COMMIT;
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No report found with -'|| P_REPORT_ID ||'ID' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'CODE- '|| SQLCODE || 'MESSAGE- ' || SQLERRM );
    END;

    FUNCTION GET_REPORT_BY_ID (
        P_REPORT_ID GATHERING_REPORTS.REPORT_ID%TYPE
    ) RETURN R_GATHERING_REPORT_TY AS
        V_REPORT R_GATHERING_REPORT_TY;
    BEGIN
        SELECT R_GATHERING_REPORT_TY ( REPORT_ID, REPORT_CONTENT, AUTHOR_ID, ORS_ID, CREATED_AT ) INTO V_REPORT
        FROM GATHERING_REPORTS
        WHERE REPORT_ID = P_REPORT_ID;
        RETURN V_REPORT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No report found with -'|| P_REPORT_ID ||'ID' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'CODE- '|| SQLCODE || 'MESSAGE- ' || SQLERRM );
    END GET_REPORT_BY_ID;

    FUNCTION GET_ALL_REPORTS RETURN T_GATHERING_REPORT_TY AS
        V_REPORT T_GATHERING_REPORT_TY;
    BEGIN
        SELECT R_GATHERING_REPORT_TY ( REPORT_ID, REPORT_CONTENT, AUTHOR_ID, ORS_ID, CREATED_AT ) BULK COLLECT INTO V_REPORT
        FROM GATHERING_REPORTS;
        RETURN V_REPORT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No report found' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'CODE- '|| SQLCODE || 'MESSAGE- ' || SQLERRM );
    END GET_ALL_REPORTS;

    FUNCTION GET_AUTHOR_REPORTS_FN (
        P_AUTHOR_ID GATHERING_REPORTS.AUTHOR_ID%TYPE
    ) RETURN T_GATHERING_REPORT_TY AS
        V_REPORT T_GATHERING_REPORT_TY;
    BEGIN
        SELECT R_GATHERING_REPORT_TY ( REPORT_ID, REPORT_CONTENT, AUTHOR_ID, ORS_ID, CREATED_AT ) BULK COLLECT INTO V_REPORT
        FROM GATHERING_REPORTS;
        RETURN V_REPORT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No report found' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'CODE- '|| SQLCODE || 'MESSAGE- ' || SQLERRM );
    END GET_AUTHOR_REPORTS_FN;

    FUNCTION GET_AUTHOR_LATEST_REPORT (
        P_AUTHOR_ID GATHERING_REPORTS.AUTHOR_ID%TYPE
    ) RETURN R_GATHERING_REPORT_TY AS
        V_REPORT R_GATHERING_REPORT_TY;
    BEGIN
        SELECT R_GATHERING_REPORT_TY ( REPORT_ID, REPORT_CONTENT, AUTHOR_ID, ORS_ID, CREATED_AT ) INTO V_REPORT
        FROM GATHERING_REPORTS
        WHERE AUTHOR_ID = P_AUTHOR_ID AND
            ROWNUM=1
        ORDER BY CREATED_AT DESC;
        RETURN V_REPORT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No report found with -'|| P_AUTHOR_ID ||'AUTHOR_ID' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'CODE- '|| SQLCODE || 'MESSAGE- ' || SQLERRM );
    END GET_AUTHOR_LATEST_REPORT;

    FUNCTION GET_ORS_REPORTS (
        P_ORS_ID GATHERING_REPORTS.ORS_ID%TYPE
    ) RETURN T_GATHERING_REPORT_TY AS
        V_REPORT T_GATHERING_REPORT_TY;
    BEGIN
        SELECT R_GATHERING_REPORT_TY ( REPORT_ID, REPORT_CONTENT, AUTHOR_ID, ORS_ID, CREATED_AT ) BULK COLLECT INTO V_REPORT
        FROM GATHERING_REPORTS
        WHERE ORS_ID = P_ORS_ID;
        RETURN V_REPORT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No report found with ' ||P_ORS_ID|| ' ORS_ID' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'CODE- '|| SQLCODE || 'MESSAGE- ' || SQLERRM );
    END GET_ORS_REPORTS;

    FUNCTION GET_ORS_REPORTS (
        P_ORS_NAME ORS.ORS_NAME%TYPE
    ) RETURN T_GATHERING_REPORT_TY AS
        V_REPORT T_GATHERING_REPORT_TY;
    BEGIN
        SELECT R_GATHERING_REPORT_TY ( REPORT_ID, REPORT_CONTENT, AUTHOR_ID, ORS_ID, CREATED_AT ) BULK COLLECT INTO V_REPORT
        FROM GATHERING_REPORTS
        WHERE ORS_ID IN (
                SELECT ORS_ID
                FROM ORS
                WHERE ORS_NAME = P_ORS_NAME
            );
        RETURN V_REPORT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No report found about ' ||P_ORS_NAME|| ' ORS' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'CODE- '|| SQLCODE || 'MESSAGE- ' || SQLERRM );
    END GET_ORS_REPORTS;
END GATHERING_PKG;
/

--PACKEGES/EVENTS.PCK
CREATE OR REPLACE PACKAGE EVENTS_PKG IS

    PROCEDURE CREATE_EVENT (
        P_EVENT_NAME IN VARCHAR2,
        P_EVENT_DESCRIPTION IN VARCHAR2,
        P_DATE_START IN TIMESTAMP,
        P_DATE_END IN TIMESTAMP
    );

    PROCEDURE CREATE_EVENT (
        P_EVENT_NAME IN VARCHAR2,
        P_DATE_START IN TIMESTAMP,
        P_DATE_END IN TIMESTAMP
    );

    PROCEDURE READ_EVENT (
        P_EVENT_ID IN NUMBER,
        P_EVENT OUT EVENTS%ROWTYPE
    );

    PROCEDURE UPDATE_EVENT (
        P_EVENT_ID IN NUMBER,
        P_EVENT_NAME IN VARCHAR2,
        P_EVENT_DESCRIPTION IN VARCHAR2,
        P_DATE_START IN TIMESTAMP,
        P_DATE_END IN TIMESTAMP
    );

    PROCEDURE UPDATE_EVENT (
        P_EVENT IN EVENTS%ROWTYPE
    );

    PROCEDURE DELETE_EVENT (
        P_EVENT_ID IN NUMBER
    );
END EVENTS_PKG;
/

CREATE OR REPLACE PACKAGE BODY EVENTS_PKG IS

    PROCEDURE CREATE_EVENT (
        P_EVENT_NAME IN VARCHAR2,
        P_EVENT_DESCRIPTION IN VARCHAR2,
        P_DATE_START IN TIMESTAMP,
        P_DATE_END IN TIMESTAMP
    ) IS
    BEGIN
        INSERT INTO EVENTS (
            EVENT_NAME,
            EVENT_DESCRIPTION,
            DATE_START,
            DATE_END
        ) VALUES (
            P_EVENT_NAME,
            P_EVENT_DESCRIPTION,
            P_DATE_START,
            P_DATE_END
        );
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END CREATE_EVENT;

    PROCEDURE CREATE_EVENT (
        P_EVENT_NAME IN VARCHAR2,
        P_DATE_START IN TIMESTAMP,
        P_DATE_END IN TIMESTAMP
    ) IS
    BEGIN
        INSERT INTO EVENTS (
            EVENT_NAME,
            DATE_START,
            DATE_END
        ) VALUES (
            P_EVENT_NAME,
            P_DATE_START,
            P_DATE_END
        );
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END CREATE_EVENT;

    PROCEDURE READ_EVENT (
        P_EVENT_ID IN NUMBER,
        P_EVENT OUT EVENTS%ROWTYPE
    ) IS
    BEGIN
        SELECT * INTO P_EVENT
        FROM EVENTS
        WHERE EVENT_ID = P_EVENT_ID;
    EXCEPTION
        WHEN TOO_MANY_ROWS THEN
            DBMS_OUTPUT.PUT_LINE ( 'Too many rows has returned - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END READ_EVENT;

    PROCEDURE UPDATE_EVENT (
        P_EVENT_ID IN NUMBER,
        P_EVENT_NAME IN VARCHAR2,
        P_EVENT_DESCRIPTION IN VARCHAR2,
        P_DATE_START IN TIMESTAMP,
        P_DATE_END IN TIMESTAMP
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        UPDATE EVENTS
        SET
            EVENT_NAME = P_EVENT_NAME,
            EVENT_DESCRIPTION = P_EVENT_DESCRIPTION,
            DATE_START = P_DATE_START,
            DATE_END = P_DATE_END
        WHERE
            EVENT_ID = P_EVENT_ID;
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END UPDATE_EVENT;

    PROCEDURE UPDATE_EVENT (
        P_EVENT IN EVENTS%ROWTYPE
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        UPDATE EVENTS
        SET
            EVENT_NAME = P_EVENT.EVENT_NAME,
            EVENT_DESCRIPTION = P_EVENT.EVENT_DESCRIPTION,
            DATE_START = P_EVENT.DATE_START,
            DATE_END = P_EVENT.DATE_END
        WHERE
            EVENT_ID = P_EVENT.EVENT_ID;
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END UPDATE_EVENT;

    PROCEDURE DELETE_EVENT (
        P_EVENT_ID IN NUMBER
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        DELETE FROM EVENTS
        WHERE
            EVENT_ID = P_EVENT_ID;
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT .PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END DELETE_EVENT;
END EVENTS_PKG;
/

--PACKEGES/DUTY.PCK
CREATE OR REPLACE PACKAGE DUTY_PKG AS

    PROCEDURE INSERT_DUTY (
        P_DUTY_NAME IN VARCHAR2,
        P_DUTY_DESCRIPTION IN VARCHAR2
    );

    PROCEDURE UPDATE_DUTY (
        P_DUTY_ID IN NUMBER,
        P_DUTY_NAME IN VARCHAR2,
        P_DUTY_DESCRIPTION IN VARCHAR2
    );

    PROCEDURE DELETE_DUTY (
        P_DUTY_ID IN NUMBER
    );

    FUNCTION GET_DUTIES_FUNC RETURN T_DUTY_TY;
END DUTY_PKG;
/

CREATE OR REPLACE PACKAGE BODY DUTY_PKG AS

    PROCEDURE INSERT_DUTY (
        P_DUTY_NAME IN VARCHAR2,
        P_DUTY_DESCRIPTION IN VARCHAR2
    ) AS
    BEGIN
        INSERT INTO DUTIES (
            DUTY_NAME,
            DUTY_DESCRIPTION
        ) VALUES (
            P_DUTY_NAME,
            P_DUTY_DESCRIPTION
        );
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE ( 'No rows inserted.' );
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END INSERT_DUTY;

    PROCEDURE UPDATE_DUTY (
        P_DUTY_ID IN NUMBER,
        P_DUTY_NAME IN VARCHAR2,
        P_DUTY_DESCRIPTION IN VARCHAR2
    ) AS
    BEGIN
        UPDATE DUTIES
        SET
            DUTY_NAME = P_DUTY_NAME,
            DUTY_DESCRIPTION = P_DUTY_DESCRIPTION
        WHERE
            DUTY_ID = P_DUTY_ID;
        IF SQL%ROWCOUNT = 0 THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR ( -22000, 'Duty ID not found' );
        END IF;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END UPDATE_DUTY;

    PROCEDURE DELETE_DUTY (
        P_DUTY_ID IN NUMBER
    ) AS
    BEGIN
        DELETE FROM DUTIES
        WHERE
            DUTY_ID = P_DUTY_ID;
        IF SQL%ROWCOUNT = 0 THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR ( -22000, 'Duty ID not found' );
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
    END DELETE_DUTY;

    FUNCTION GET_DUTIES_FUNC RETURN T_DUTY_TY IS
        V_DUTY_TABLE T_DUTY_TY;
    BEGIN
        SELECT DUTY_TY ( DUTY_ID, DUTY_NAME, DUTY_DESCRIPTION ) BULK COLLECT INTO V_DUTY_TABLE
        FROM DUTIES;
        RETURN V_DUTY_TABLE;
    END;
END DUTY_PKG;
/

--Triggerek
-- Szekvencia kiosztásra létrehozott fájlból triggers/sequence_manager.trg
-- ORS
CREATE OR REPLACE TRIGGER ORS_SEQ_TRG BEFORE
    INSERT ON ORS FOR EACH ROW
BEGIN
    IF :NEW.ORS_ID IS NULL THEN
        :NEW.ORS_ID := ORS_PATROL_SEQ.NEXTVAL;
    END IF;
END ORS_SEQ_TRG;
/

-- PATROL
CREATE OR REPLACE TRIGGER PATROL_SEQ_TRG BEFORE
    INSERT ON PATROL FOR EACH ROW
BEGIN
    IF :NEW.PATROL_ID IS NULL THEN
        :NEW.PATROL_ID := ORS_PATROL_SEQ.NEXTVAL;
    END IF;
END PATROL_SEQ_TRG;
/

-- RANK_DIC
CREATE OR REPLACE TRIGGER RANK_DICTIONARY_SEQ_TRG BEFORE
    INSERT ON RANK_DICTIONARY FOR EACH ROW
BEGIN
    IF :NEW.RANK_ID IS NULL THEN
        :NEW.RANK_ID := RANKS_SEQ.NEXTVAL;
    END IF;
END RANK_DICTIONARY_SEQ_TRG;
/

--RANK_PRIV
CREATE OR REPLACE TRIGGER RANK_PRIVELEGES_SEQ_TRG BEFORE
    INSERT ON RANK_PRIVILEGES FOR EACH ROW
BEGIN
    IF :NEW.STATUS_ID IS NULL THEN
        :NEW.STATUS_ID := RANKS_SEQ.NEXTVAL;
    END IF;
END RANK_PRIVELEGES_SEQ_TRG;
/

-- --POSTS
-- CREATE OR REPLACE TRIGGER POSTS_SEQ_TRG BEFORE
--     INSERT ON POSTS FOR EACH ROW
-- BEGIN
--     IF :NEW.POST_ID IS NULL THEN
--         :NEW.POST_ID := POSTS_SEQ.NEXTVAL;
--     END IF;
-- END POSTS_SEQ_TRG;
-- /

--MEMBERS
CREATE OR REPLACE TRIGGER MEMBERS_SEQ_TRG BEFORE
    INSERT ON MEMBERS FOR EACH ROW
BEGIN
    IF :NEW.MEMBER_ID IS NULL THEN
        :NEW.MEMBER_ID := MEMBERS_SEQ.NEXTVAL;
    END IF;
END MEMBERS_SEQ_TRG;
/

--MEETING
CREATE OR REPLACE TRIGGER MEETING_SEQ_TRG BEFORE
    INSERT ON MEETING FOR EACH ROW
BEGIN
    IF :NEW.MEETING_ID IS NULL THEN
        :NEW.MEETING_ID := REPORTS_SEQ.NEXTVAL;
    END IF;
END MEETING_SEQ_TRG;
/

-- --KNOWLEDGE
-- CREATE OR REPLACE TRIGGER KNOWLEDGE_SEQ_TRG BEFORE
--     INSERT ON KNOWLEDGE FOR EACH ROW
-- BEGIN
--     IF :NEW.KNOWLEDGE_ID IS NULL THEN
--         :NEW.KNOWLEDGE_ID := KNOWLEDGE_MEDIA_SEQ.NEXTVAL;
--     END IF;
-- END KNOWLEDGE_SEQ_TRG;
-- /

-- --MEDIA
-- CREATE OR REPLACE TRIGGER MEDIA_SEQ_TRG BEFORE
--     INSERT ON MEDIA FOR EACH ROW
-- BEGIN
--     IF :NEW.MEDIA_ID IS NULL THEN
--         :NEW.MEDIA_ID := KNOWLEDGE_MEDIA_SEQ.NEXTVAL;
--     END IF;
-- END MEDIA_SEQ_TRG;
-- /

--PERS_HIS
CREATE OR REPLACE TRIGGER PERSONAL_HIS_SEQ_TRG BEFORE
    INSERT ON PERSONAL_HISTORY FOR EACH ROW
BEGIN
    IF :NEW.LOG_ID IS NULL THEN
        :NEW.LOG_ID := HISTORY_SEQ.NEXTVAL;
    END IF;
END PERSONAL_HISTORY_SEQ_TRG;
/

--REPORT_HIS
CREATE OR REPLACE TRIGGER REPORT_HIS_SEQ_TRG BEFORE
    INSERT ON REPORT_HISTORY FOR EACH ROW
BEGIN
    IF :NEW.LOG_ID IS NULL THEN
        :NEW.LOG_ID := HISTORY_SEQ.NEXTVAL;
    END IF;
END REPORT_HISTORY_SEQ_TRG;
/

--INTERNAL_HIS
CREATE OR REPLACE TRIGGER INTERNAL_ASS_HIS_SEQ_TRG BEFORE
    INSERT ON INTERNAL_ASSIGNS_HISTORY FOR EACH ROW
BEGIN
    IF :NEW.LOG_ID IS NULL THEN
        :NEW.LOG_ID := HISTORY_SEQ.NEXTVAL;
    END IF;
END INTERNAL_ASS_HIS_SEQ_TRG;
/

--PUBLIC_HIS
CREATE OR REPLACE TRIGGER PUBLIC_ACT_HIS_SEQ_TRG BEFORE
    INSERT ON PUBLIC_ACTIVITIES_HISTORY FOR EACH ROW
BEGIN
    IF :NEW.LOG_ID IS NULL THEN
        :NEW.LOG_ID := HISTORY_SEQ.NEXTVAL;
    END IF;
END PUBLIC_ACT_HIS_SEQ_TRG;
/

--GATHERING
CREATE OR REPLACE TRIGGER GATHERING_REPORTS_SEQ_TRG BEFORE
    INSERT ON GATHERING_REPORTS FOR EACH ROW
BEGIN
    IF :NEW.REPORT_ID IS NULL THEN
        :NEW.REPORT_ID := REPORTS_SEQ.NEXTVAL;
    END IF;
END GATHERING_REPORTS_SEQ_TRG;
/

--EVENTS
CREATE OR REPLACE TRIGGER EVENTS_SEQ_TRG BEFORE
    INSERT ON EVENTS FOR EACH ROW
BEGIN
    IF :NEW.EVENT_ID IS NULL THEN
        :NEW.EVENT_ID := REPORTS_SEQ.NEXTVAL;
    END IF;
END EVENTS_SEQ_TRG;
/

--DUTIES
CREATE OR REPLACE TRIGGER DUTIES_SEQ_TRG BEFORE
    INSERT ON DUTIES FOR EACH ROW
BEGIN
    IF :NEW.DUTY_ID IS NULL THEN
        :NEW.DUTY_ID := DUTY_SEQ.NEXTVAL;
    END IF;
END DUTIES_SEQ_TRG;
/

--ADDRESS
CREATE OR REPLACE TRIGGER ADDRESS_SEQ_TRG BEFORE
    INSERT ON ADDRESS FOR EACH ROW
BEGIN
    IF :NEW.ADDRESS_ID IS NULL THEN
        :NEW.ADDRESS_ID := ADDRESS_SEQ.NEXTVAL;
    END IF;
END ADDRESS_SEQ_TRG;
/

--TRIGGERS/SYSTEM.TRG
CREATE OR REPLACE TRIGGER STARTUP_TRIGGER AFTER STARTUP ON DATABASE
BEGIN
    CONSTANTS_PKG.INIT_RANKS;
END STARTUP_TRIGGER;
/

--TRIGGERS/MEMBERS.TRG
CREATE OR REPLACE TRIGGER MEMBER_LOG_TRG AFTER
    INSERT OR UPDATE OR DELETE ON MEMBERS FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    V_OPERATION PERSONAL_HISTORY.TR_NAME%TYPE;
    V_MESSAGE   PERSONAL_HISTORY.LOG_MSSG%TYPE;
BEGIN
    CASE
        WHEN INSERTING THEN
            V_OPERATION := 'SUCCESSFULL_INSERT';
            V_MESSAGE := 'MEMBER-'||:NEW.MEMBER_ID||'- CREATED: ';
        WHEN UPDATING THEN
            V_OPERATION := 'SUCCESSFULL_UPDATE';
            V_MESSAGE := 'MEMBER-'||:NEW.MEMBER_ID||'- UPDATED';
        WHEN DELETING THEN
            V_OPERATION := 'SUCCESSFULL_DELETE';
            V_MESSAGE := 'MEMBER-'||:OLD.MEMBER_ID||'- DELETED';
    END CASE;

    INSERT INTO PERSONAL_HISTORY (
        CHANGER,
        LOG_MSSG,
        MODIFIED_TABLE,
        TR_NAME
    ) VALUES (
        USER,
        V_MESSAGE,
        'MEMBERS',
        V_OPERATION
    );
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE ( 'An error was encountered - ' || SQLCODE || ' -ERROR- ' || SQLERRM );
        CASE
            WHEN INSERTING THEN
                V_OPERATION := 'FAIL_INSERT';
                V_MESSAGE := 'MEMBER-'||:NEW.MEMBER_ID||'- CREATED: ';
            WHEN UPDATING THEN
                V_OPERATION := 'FAIL_UPDATE';
                V_MESSAGE := 'MEMBER-'||:NEW.MEMBER_ID||'- UPDATED';
            WHEN DELETING THEN
                V_OPERATION := 'FAIL_DELETE';
                V_MESSAGE := 'MEMBER-'||:OLD.MEMBER_ID||'- DELETED';
        END CASE;

        INSERT INTO PERSONAL_HISTORY (
            CHANGER,
            LOG_MSSG,
            MODIFIED_TABLE,
            TR_NAME
        ) VALUES (
            USER,
            V_MESSAGE,
            'MEMBERS',
            V_OPERATION
        );
        COMMIT;
END;
/

-- TRIGGERS/ADDRESS.TRG
CREATE OR REPLACE TRIGGER ADDRESS_LOG AFTER
    INSERT OR UPDATE OR DELETE ON ADDRESS FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    V_OPERATION PERSONAL_HISTORY.TR_NAME%TYPE;
    V_MESSAGE   PERSONAL_HISTORY.LOG_MSSG%TYPE;
BEGIN
    CASE
        WHEN INSERTING THEN
            V_OPERATION := 'SUCCESSFUL_INSERT';
            V_MESSAGE := 'Address ' || V_OPERATION || ': ' || :NEW.ZIP_CODE || ', ' || :NEW.COUNTRY || ', ' || :NEW.CITY || ', ' || :NEW.STREET_NAME || ', ' || :NEW.STREET_TYPE || ', ' || :NEW.HOUSE_NUMBER;
        WHEN UPDATING THEN
            V_OPERATION := 'SUCCESSFUL_UPDATE';
            V_MESSAGE := 'Address ' || V_OPERATION || ' NEW: ' || :NEW.ZIP_CODE || ', ' || :NEW.COUNTRY || ', ' || :NEW.CITY || ', ' || :NEW.STREET_NAME || ', ' || :NEW.STREET_TYPE || ', ' || :NEW.HOUSE_NUMBER;
            V_MESSAGE := V_MESSAGE || CHR ( 10 ) ||'OLD: ' || :OLD.ZIP_CODE || ', ' || :OLD.COUNTRY || ', ' || :OLD.CITY || ', ' || :OLD.STREET_NAME || ', ' || :OLD.STREET_TYPE || ', ' || :OLD.HOUSE_NUMBER;
        WHEN DELETING THEN
            V_OPERATION := 'SUCCESSFUL_DELETE';
            V_MESSAGE := 'Address ' || V_OPERATION || ': ' || :OLD.ZIP_CODE || ', ' || :OLD.COUNTRY || ', ' || :OLD.CITY || ', ' || :OLD.STREET_NAME || ', ' || :OLD.STREET_TYPE || ', ' || :OLD.HOUSE_NUMBER;
    END CASE;

    INSERT INTO PERSONAL_HISTORY (
        CHANGER,
        LOG_MSSG,
        MODIFIED_TABLE,
        TR_NAME
    ) VALUES (
        USER,
        V_MESSAGE,
        'ADDRESS',
        V_OPERATION
    );
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        CASE
            WHEN INSERTING THEN
                V_OPERATION := 'FAIL_INSERT';
            WHEN UPDATING THEN
                V_OPERATION := 'FAIL_UPDATE';
            WHEN DELETING THEN
                V_OPERATION := 'FAIL_DELETE';
        END CASE;

        INSERT INTO PERSONAL_HISTORY (
            CHANGER,
            LOG_MSSG,
            MODIFIED_TABLE,
            TR_NAME
        ) VALUES (
            USER,
            V_MESSAGE,
            'ADDRESS',
            V_OPERATION
        );
        COMMIT;
END;
/

--TRIGGERS/DUTY.TRG
CREATE OR REPLACE TRIGGER EVENT_DUTIES_ASS_TRG BEFORE
    INSERT OR UPDATE ON EVENT_DUTIES_ASS FOR EACH ROW
BEGIN
    IF :NEW.ASSIGNMENT_END_DATE IS NOT NULL AND :NEW.ASSIGNMENT_END_DATE >= SYSDATE THEN
        RAISE EXCEPTIONS_PKG.ASSIGMENT_DATE_EXC;
    END IF;
EXCEPTION
    WHEN EXCEPTIONS_PKG.ASSIGMENT_DATE_EXC THEN
        DBMS_OUTPUT.PUT_LINE ( 'The assignment date is not in the future!' );
END;
/

CREATE OR REPLACE TRIGGER EVENT_DUTIES_ASS_LOG_TRG BEFORE
    INSERT OR UPDATE OR DELETE ON EVENT_DUTIES_ASS FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    V_OPERATION PUBLIC_ACTIVITIES_HISTORY.TR_NAME%TYPE;
    V_MESSAGE   PUBLIC_ACTIVITIES_HISTORY.LOG_MSSG%TYPE;
BEGIN
    CASE
        WHEN INSERTING THEN
            V_OPERATION := 'SUCCESSFUL_INSERT';
            V_MESSAGE := 'EVENT_DUTIES_ASSOSIATIVE ' || V_OPERATION || ': ' || :NEW.EVENT_ID || ', ' || :NEW.DUTY_ID || ', ' || :NEW.MEMBER_ID || ', ' || :NEW.ASSIGNMENT_END_DATE;
        WHEN UPDATING THEN
            V_OPERATION := 'SUCCESSFUL_UPDATE';
            V_MESSAGE := 'EVENT_DUTIES_ASSOSIATIVE ' || V_OPERATION || 'NEW: ' || :NEW.EVENT_ID || ', ' || :NEW.DUTY_ID || ', ' || :NEW.MEMBER_ID || ', ' || :NEW.ASSIGNMENT_END_DATE;
            V_MESSAGE := V_MESSAGE ||CHR ( 10 ) || 'OLD: ' || :OLD.EVENT_ID || ', ' || :OLD.DUTY_ID || ', ' || :OLD.MEMBER_ID || ', ' || :OLD.ASSIGNMENT_END_DATE;
        WHEN DELETING THEN
            V_OPERATION := 'SUCCESSFUL_DELETE';
            V_MESSAGE := 'EVENT_DUTIES_ASSOSIATIVE ' || V_OPERATION || ': ' || :OLD.EVENT_ID || ', ' || :OLD.DUTY_ID || ', ' || :OLD.MEMBER_ID || ', ' || :OLD.ASSIGNMENT_END_DATE;
    END CASE;

    INSERT INTO PUBLIC_ACTIVITIES_HISTORY (
        CHANGER,
        LOG_MSSG,
        MODIFIED_TABLE,
        TR_NAME
    ) VALUES (
        USER,
        V_MESSAGE,
        'ADDRESS',
        V_OPERATION
    );
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        CASE
            WHEN INSERTING THEN
                V_OPERATION := 'FAIL_INSERT';
            WHEN UPDATING THEN
                V_OPERATION := 'FAIL_UPDATE';
            WHEN DELETING THEN
                V_OPERATION := 'FAIL_DELETE';
        END CASE;

        INSERT INTO PUBLIC_ACTIVITIES_HISTORY (
            CHANGER,
            LOG_MSSG,
            MODIFIED_TABLE,
            TR_NAME
        ) VALUES (
            USER,
            V_MESSAGE,
            'ADDRESS',
            V_OPERATION
        );
        COMMIT;
END EVENT_DUTIES_ASS_LOG_TRG;
/

--TRIGGERS/ORS.TRG
CREATE OR REPLACE TRIGGER ORS_CH_LEADER_TRG BEFORE
    INSERT OR UPDATE ON ORS FOR EACH ROW
DECLARE
    V_LEADER_COUNT NUMBER;
BEGIN
    IF :NEW.LEADER_ID IS NULL THEN
        NULL;
    ELSE
        SELECT COUNT ( * ) INTO V_LEADER_COUNT
        FROM RANK_PRIVILEGES
        WHERE MEMBER_ID = :NEW.LEADER_ID AND
            RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC (
                P_MEMBER_ID => :NEW.LEADER_ID /*IN NUMBER*/,
                P_RANK_NAME => CONSTANTS_PKG.RANKS_NAMES ( 'GL' ) /*IN NUMBER*/
            ) <> 0;
        IF V_LEADER_COUNT = 0 THEN
            RAISE EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC;
        END IF;
    END IF;
EXCEPTION
    WHEN EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC THEN
        DBMS_OUTPUT.PUT_LINE ( 'Invalid privelege to be leader - '|| :NEW.LEADER_ID || ' - MEMBER_ID' );
END ORS_CH_LEADER_TRG;
/

--TRIGGERS/PATROL.TRG
CREATE OR REPLACE TRIGGER PATROL_CH_LEADER_TRG BEFORE
    INSERT OR UPDATE ON PATROL FOR EACH ROW
DECLARE
    V_LEADER_COUNT NUMBER;
BEGIN
    IF :NEW.LEADER_ID IS NULL THEN
        NULL;
    ELSE
        SELECT COUNT ( * ) INTO V_LEADER_COUNT
        FROM RANK_PRIVILEGES
        WHERE MEMBER_ID = :NEW.LEADER_ID AND
            RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC (
                P_MEMBER_ID => :NEW.LEADER_ID /*IN NUMBER*/,
                P_RANK_NAME => CONSTANTS_PKG.RANKS_NAMES ( 'PL' ) /*IN NUMBER*/
            ) <> 0;
        IF V_LEADER_COUNT = 0 THEN
            RAISE EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC;
        END IF;
    END IF;
EXCEPTION
    WHEN EXCEPTIONS_PKG.INVALID_PRIVILEGE_EXC THEN
        DBMS_OUTPUT.PUT_LINE ( 'Invalid privelege to be leader - '|| :NEW.LEADER_ID || ' - MEMBER_ID' );
END PATROL_CH_LEADER_TRG;
/

CREATE OR REPLACE TRIGGER ORS_LOG AFTER
    INSERT OR UPDATE OR DELETE ON ORS FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    V_OPERATION INTERNAL_ASSIGNS_HISTORY.TR_NAME%TYPE;
    V_MESSAGE   INTERNAL_ASSIGNS_HISTORY.LOG_MSSG%TYPE;
BEGIN
    CASE
        WHEN INSERTING THEN
            V_OPERATION := 'SUCCESSFULL_INSERT';
            V_MESSAGE := 'ORS-'||:NEW.ORS_NAME||'- CREATED: '|| :NEW.ORS_ID || ', '|| :NEW.ORS_NAME || ', '|| :NEW.PATROL_ID || ', '|| :NEW.LEADER_ID;
        WHEN UPDATING THEN
            V_OPERATION := 'SUCCESSFULL_UPDATE';
            V_MESSAGE := 'ORS-'||:NEW.ORS_NAME||'- UPDATED: '|| :NEW.ORS_ID || ', '|| :NEW.ORS_NAME || ', '|| :NEW.PATROL_ID || ', '|| :NEW.LEADER_ID;
            V_MESSAGE :=V_MESSAGE || CHR ( 10 ) ||'OLD_ORS- '|| :OLD.ORS_ID || ', '|| :OLD.ORS_NAME || ', '|| :OLD.PATROL_ID || ', '|| :OLD.LEADER_ID;
        WHEN DELETING THEN
            V_OPERATION := 'SUCCESSFULL_DELETE';
            V_MESSAGE := 'ORS-'||:OLD.ORS_NAME||'- DELETED: '|| :OLD.ORS_ID || ', '|| :OLD.ORS_NAME || ', '|| :OLD.PATROL_ID || ', '|| :OLD.LEADER_ID;
    END CASE;

    INSERT INTO PERSONAL_HISTORY (
        CHANGER,
        LOG_MSSG,
        MODIFIED_TABLE,
        TR_NAME
    ) VALUES (
        USER,
        V_MESSAGE,
        'MEMBERS',
        V_OPERATION
    );
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        CASE
            WHEN INSERTING THEN
                V_OPERATION := 'FAIL_INSERT';
                V_MESSAGE := 'ORS-'||:NEW.ORS_NAME||'- CREATED: '|| :NEW.ORS_ID || ', '|| :NEW.ORS_NAME || ', '|| :NEW.PATROL_ID || ', '|| :NEW.LEADER_ID;
            WHEN UPDATING THEN
                V_OPERATION := 'FAIL_UPDATE';
                V_MESSAGE := 'ORS-'||:NEW.ORS_NAME||'- UPDATED: '|| :NEW.ORS_ID || ', '|| :NEW.ORS_NAME || ', '|| :NEW.PATROL_ID || ', '|| :NEW.LEADER_ID;
                V_MESSAGE :=V_MESSAGE || CHR ( 10 ) ||'OLD_ORS- '|| :OLD.ORS_ID || ', '|| :OLD.ORS_NAME || ', '|| :OLD.PATROL_ID || ', '|| :OLD.LEADER_ID;
            WHEN DELETING THEN
                V_OPERATION := 'FAIL_DELETE';
                V_MESSAGE := 'ORS-'||:OLD.ORS_NAME||'- DELETED: '|| :OLD.ORS_ID || ', '|| :OLD.ORS_NAME || ', '|| :OLD.PATROL_ID || ', '|| :OLD.LEADER_ID;
        END CASE;

        INSERT INTO PERSONAL_HISTORY (
            CHANGER,
            LOG_MSSG,
            MODIFIED_TABLE,
            TR_NAME
        ) VALUES (
            USER,
            V_MESSAGE,
            'MEMBERS',
            V_OPERATION
        );
        COMMIT;
END ORS_LOG;
/

--TRIGGERS/PROMOTION.TRG
CREATE OR REPLACE TRIGGER MEMBER_PROMOTION_LOG AFTER
    INSERT OR DELETE ON RANK_PRIVILEGES FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    V_OPERATION VARCHAR2 ( 100 );
    V_MESSAGE   INTERNAL_ASSIGNS_HISTORY.LOG_MSSG%TYPE;
BEGIN
    CASE
        WHEN INSERTING THEN
            V_MESSAGE := 'INSERT_NEW_PROMOTION';
            V_OPERATION := 'INSERT';
        WHEN DELETING THEN
            V_MESSAGE := 'DELETE_DEPROMOTION';
            V_OPERATION := 'DELETE';
            IF RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC (
                P_MEMBER_ID => :OLD.MEMBER_ID /*IN NUMBER*/,
                P_RANK_NAME => CONSTANTS_PKG.RANKS_NAMES ( 'GL' ) /*IN NUMBER*/
            ) = 1 THEN
                UPDATE MEMBERS
                SET
                    ORS_ID = NULL
                WHERE
                    MEMBER_ID = :OLD.MEMBER_ID;
                V_MESSAGE := V_MESSAGE || ' GROUP LEADER ORS_ID IS SET NULL';
                COMMIT;
            END IF;
    END CASE;

    IF INSTR ( V_OPERATION, 'INSERT' ) <> 0 AND RANK_DIC_PKG.HAVE_MEMBER_RANK_BY_NAME_FUNC (
        P_MEMBER_ID => :NEW.MEMBER_ID /*IN NUMBER*/,
        P_RANK_NAME => CONSTANTS_PKG.RANKS_NAMES ( 'GL' ) /*IN VARCHAR2*/
    ) = 1 THEN
        RANK_PRIVILEGES_PGK.LEADER_TO_GROUP (
            P_LEADER_ID => :NEW.MEMBER_ID /*IN NUMBER*/
        );
        V_MESSAGE := V_MESSAGE || ' GROUP LEADER IS MOVED TO: ';
        SELECT V_MESSAGE || O.ORS_NAME INTO V_MESSAGE
        FROM GROUP_LEADERS_VW GL
            INNER JOIN ORS O
            ON GL.ORS_ID = O.ORS_ID;
    END IF;

    INSERT INTO INTERNAL_ASSIGNS_HISTORY (
        CHANGER,
        LOG_MSSG,
        MODIFIED_TABLE,
        TR_NAME
    ) VALUES (
        USER,
        V_MESSAGE,
        'RANK_PRIVILEGES',
        V_OPERATION
    );
    COMMIT;
END;
/

CREATE OR REPLACE TRIGGER RANK_DICTIONARY_LOG AFTER
    INSERT OR UPDATE OR DELETE ON RANK_DICTIONARY FOR EACH ROW
DECLARE
    V_OPERATION VARCHAR2 ( 100 );
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    CASE
        WHEN INSERTING THEN
            V_OPERATION := 'INSERT';
        WHEN UPDATING THEN
            V_OPERATION := 'UPDATE';
        WHEN DELETING THEN
            V_OPERATION := 'DELETE';
    END CASE;

    INSERT INTO INTERNAL_ASSIGNS_HISTORY (
        CHANGER,
        LOG_MSSG,
        MODIFIED_TABLE,
        TR_NAME
    ) VALUES (
        USER,
        'Rank ' || V_OPERATION || ': ' || :NEW.RANK_NAME,
        V_OPERATION,
        'RANK_DICTIONARY'
    );
    COMMIT;
END RANK_DICTIONARY_LOG;
/

CREATE OR REPLACE TRIGGER RANK_CONSTANT_UPDATE_TRG AFTER
    INSERT OR UPDATE OR DELETE ON RANK_DICTIONARY
DECLARE
BEGIN
    CONSTANTS_PKG .INIT_RANKS;
END RANK_CONSTANT_UPDATE_TRG;
/

-- TRIGGERS/REPORTS.TRG
CREATE OR REPLACE TRIGGER GATHERING_REPORT_LOG AFTER
    INSERT OR UPDATE OR DELETE ON GATHERING_REPORTS FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    V_OPERATION VARCHAR2 ( 100 );
    V_MESSAGE   REPORT_HISTORY.LOG_MSSG%TYPE;
BEGIN
    CASE
        WHEN INSERTING THEN
            V_OPERATION := 'INSERT';
            INSERT INTO REPORT_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'REPORT ' || V_OPERATION || 'ON - ' || :NEW.ORS_ID,
                V_OPERATION,
                'GATHERING_REPORTS'
            );
        WHEN UPDATING THEN
            V_OPERATION := 'UPDATE';
            INSERT INTO REPORT_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'REPORT ' || V_OPERATION || 'ON - ' || :NEW.ORS_ID,
                V_OPERATION,
                'GATHERING_REPORTS'
            );
        WHEN DELETING THEN
            V_OPERATION := 'DELETE';
            INSERT INTO REPORT_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'REPORT ' || V_OPERATION || 'ON - ' || :OLD.ORS_ID,
                V_OPERATION,
                'GATHERING_REPORTS'
            );
    END CASE;

    COMMIT;
END GATHERING_REPORT_LOG;
/

CREATE OR REPLACE TRIGGER GATHERING_REPORT_MOD_TRG BEFORE
    UPDATE ON GATHERING_REPORTS FOR EACH ROW
DECLARE
BEGIN
    :NEW.MODIFIED_AT := SYSTIMESTAMP;
END GATHERING_REPORT_MOD_TRG;
/

CREATE OR REPLACE TRIGGER MEETING_REPORT_LOG AFTER
    INSERT OR UPDATE OR DELETE ON MEETING FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    V_OPERATION VARCHAR2 ( 100 );
    V_MESSAGE   REPORT_HISTORY.LOG_MSSG%TYPE;
BEGIN
    CASE
        WHEN INSERTING THEN
            V_OPERATION := 'INSERT';
            INSERT INTO REPORT_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'REPORT ' || V_OPERATION || 'ON - ' || :NEW.MEETING_ID,
                V_OPERATION,
                'MEETING'
            );
        WHEN UPDATING THEN
            V_OPERATION := 'UPDATE';
            INSERT INTO REPORT_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'REPORT ' || V_OPERATION || 'ON - ' || :NEW.MEETING_ID,
                V_OPERATION,
                'MEETING'
            );
        WHEN DELETING THEN
            V_OPERATION := 'DELETE';
            INSERT INTO REPORT_HISTORY (
                CHANGER,
                LOG_MSSG,
                MODIFIED_TABLE,
                TR_NAME
            ) VALUES (
                USER,
                'REPORT ' || V_OPERATION || 'ON - ' || :OLD.MEETING_ID,
                V_OPERATION,
                'MEETING'
            );
    END CASE;

    COMMIT;
END MEETING_REPORT_LOG;
/

CREATE OR REPLACE TRIGGER MEETING_REPORT_MOD_TRG BEFORE
    UPDATE ON MEETING FOR EACH ROW
DECLARE
BEGIN
    :NEW.MODIFIED_AT := SYSTIMESTAMP;
END MEETING_REPORT_MOD_TRG;
/

--JOBS
--JOBS/PROMOTION_JOB.PLSQL
BEGIN
 
    -- job ahhoz hogy a rank_privileges.promotion_time ne legyen réggebbi mint 1 év --> job ehhez
    DBMS_SCHEDULER.CREATE_JOB (
        JOB_NAME => 'Clear_invalid_promotions' /*IN VARCHAR2*/,
        JOB_TYPE => 'STORED_PROCEDURE' /*IN VARCHAR2*/,
        JOB_ACTION => 'RANK_PRIVILEGES_PKG.VALIDATE_PROMOTION_TIME' /*IN VARCHAR2*/,
        START_DATE => SYSTIMESTAMP /*IN TIMESTAMP WITH TIME ZONE*/,
        REPEAT_INTERVAL => 'FREQ=WEEKLY; BYDAY=SAT;' /*IN VARCHAR2*/,
        ENABLED => TRUE /*IN BOOLEAN*/,
        AUTO_DROP => FALSE /*IN BOOLEAN*/,
        COMMENTS => 'This job is responsible to handle invalidated/expired privilege/rank' /*IN VARCHAR2*/
    );
END;
/

-- INIT DATA
DECLARE
    V_PATROL_ID        NUMBER;
    V_GROUP_LEADER_ID  NUMBER;
    V_GROUP_MEMBER_ID  NUMBER;
    V_PATROL_LEADER_ID NUMBER;
    V_ADDRESS_ID       NUMBER;
    V_MEMBER           MEMBER_TY;
    V_ERROR_BACKTRACE  VARCHAR2 ( 4000 );
BEGIN
    RANK_DIC_PKG.CREATE_NEW_RANK (
        P_RANK_NAME => 'GROUP LEADER' /*IN VARCHAR2*/
    );
    RANK_DIC_PKG.CREATE_NEW_RANK (
        P_RANK_NAME => 'PATROL LEADER' /*IN VARCHAR2*/
    );
    CONSTANTS_PKG.INIT_RANKS;
    V_MEMBER := MEMBER_TY ( FIRST_NAME => 'Benjamin', LAST_NAME => 'Hang', MOTHERS_NAME => 'Szabó Kata', MOTHERS_TELEPHONE_NUMBER => '+363214215', MOTHERS_EMAIL => 'ghdsj@dsa.com', ORS_ID => NULL );
 
    -- Group leader Member
    MEMBER_PKG.CREATE_MEMBER (
        P_MEMBER =>V_MEMBER
    );
 
    -- INSERT INTO MEMBERS (
    --     FIRST_NAME,
    --     LAST_NAME,
    --     MOTHERS_NAME,
    --     MOTHERS_TELEPHONE_NUMBER,
    --     MOTHERS_EMAIL
    -- ) VALUES (
    --  'Benjamin',
    --  'Hang',
    --  'Szabó Kata',
    --  '+363214215',
    --  'ghdsj@dsa.com'
    -- );
    V_MEMBER := MEMBER_TY ( FIRST_NAME => 'Zsombor', LAST_NAME => 'Nagy', MOTHERS_NAME => 'Kovács Anikó', MOTHERS_TELEPHONE_NUMBER => '+363213315', MOTHERS_EMAIL => 'gfdssj@ssa.com', ORS_ID => NULL );
 
    -- Patrol leader Member
    MEMBER_PKG.CREATE_MEMBER (
        P_MEMBER =>V_MEMBER
    );
 
    --     INSERT INTO MEMBERS (
    --     FIRST_NAME,
    --     LAST_NAME,
    --     MOTHERS_NAME,
    --     MOTHERS_TELEPHONE_NUMBER,
    --     MOTHERS_EMAIL
    -- ) VALUES (
    --     'Zsombor',
    --     'Nagy',
    --     'Kovács Anikó',
    --     '+363213315',
    --     'gfdssj@ssa.com'
    -- );
    SELECT MEMBER_ID INTO V_GROUP_LEADER_ID
    FROM MEMBERS
    WHERE FIRST_NAME = 'Benjamin';
    SELECT MEMBER_ID INTO V_PATROL_LEADER_ID
    FROM MEMBERS
    WHERE FIRST_NAME = 'Zsombor';
 
    -- Promote member to group leader
    RANK_PRIVILEGES_PGK.PROMOTE_MEMBER (
        P_MEMBER_ID => V_GROUP_LEADER_ID /*IN NUMBER*/,
        P_RANK_ID => RANK_DIC_PKG.GET_RANK_ID_BY_NAME ( P_RANK_NAME =>CONSTANTS_PKG.RANKS_NAMES ( 'GL' ) ) /*IN NUMBER*/
    );
 
    -- Promote member to patrol leader
    RANK_PRIVILEGES_PGK.PROMOTE_MEMBER (
        P_MEMBER_ID => V_PATROL_LEADER_ID /*IN NUMBER*/,
        P_RANK_ID => RANK_DIC_PKG.GET_RANK_ID_BY_NAME ( P_RANK_NAME => CONSTANTS_PKG.RANKS_NAMES ( 'PL' ) ) /*IN NUMBER*/
    );
 
    -- Patrol
    PATROL_PKG.CREATE_PATROL (
        P_NAME => 'Zsaboborczki Raj' /*IN VARCHAR2*/,
        P_LEADER_ID => V_PATROL_LEADER_ID
    );
    SELECT PATROL_ID INTO V_PATROL_ID
    FROM PATROL
    WHERE PATROL_NAME='Zsaboborczki Raj';
 
    -- Group
    ORS_PKG.CREATE_ORS (
        P_NAME => 'TIGRIS' /*IN VARCHAR2*/,
        P_PATROL_ID => V_PATROL_ID /*IN NUMBER*/,
        P_LEADER_ID => V_GROUP_LEADER_ID /*IN NUMBER*/
    );
    V_MEMBER := MEMBER_TY ( FIRST_NAME => 'Levente', LAST_NAME => 'Szabó', MOTHERS_NAME => 'Takács Kata', MOTHERS_TELEPHONE_NUMBER => '+364561563', MOTHERS_EMAIL => 'fffsj@dsa.com', ORS_ID => ORS_PKG.GET_ORS_BY_NAME_FUNC ( P_ORS_NAME => 'TIGRIS' /*IN VARCHAR2*/ ) );
 
    -- Group member
    MEMBER_PKG.CREATE_MEMBER (
        P_MEMBER =>V_MEMBER
    );
 
    --Assign patrol leader to patrol with procedure, but it will display error
    PATROL_PKG.ASSIGN_LEADER_TO_PATROL (
        P_LEADER_ID => V_PATROL_LEADER_ID /*IN NUMBER*/,
        P_PATROL_ID => V_PATROL_ID /*IN NUMBER*/
    );
    ADDRESS_PKG.CREATE_ADDRESS (
        P_ZIP_CODE => '8000' /*IN VARCHAR2*/,
        P_COUNTRY => 'HUNGARY' /*IN VARCHAR2*/,
        P_CITY =>'SIÓFOK' /*IN VARCHAR2*/,
        P_STREET_NAME =>'LIDÓ' /*IN VARCHAR2*/,
        P_STREET_TYPE =>'UTCA' /*IN VARCHAR2*/,
        P_HOUSE_NUMBER => '2' /*IN VARCHAR2*/
    );
 
    --Address Create
    ADDRESS_PKG.CREATE_ADDRESS (
        P_ZIP_CODE => '8020' /*IN VARCHAR2*/,
        P_COUNTRY => 'HUNGARY' /*IN VARCHAR2*/,
        P_CITY =>'TAB' /*IN VARCHAR2*/,
        P_STREET_NAME =>'KOSSUTH' /*IN VARCHAR2*/,
        P_STREET_TYPE =>'UTCA' /*IN VARCHAR2*/,
        P_HOUSE_NUMBER => '22' /*IN VARCHAR2*/
    );
    ADDRESS_PKG.CREATE_ADDRESS (
        P_ZIP_CODE => '8020' /*IN VARCHAR2*/,
        P_COUNTRY => 'HUNGARY' /*IN VARCHAR2*/,
        P_CITY =>'TAB' /*IN VARCHAR2*/,
        P_STREET_NAME =>'KOSSUTH' /*IN VARCHAR2*/,
        P_STREET_TYPE =>'UTCA' /*IN VARCHAR2*/,
        P_HOUSE_NUMBER => '22' /*IN VARCHAR2*/
    );
 
    --Address Assigns
    SELECT ADDRESS_ID INTO V_ADDRESS_ID
    FROM ADDRESS
    WHERE CITY = 'SIÓFOK';
    ADDRESS_PKG.ASSIGN_MEMBER_TO_ADDRESS (
        P_MEMBER_ID => V_PATROL_LEADER_ID /*IN NUMBER*/,
        P_ADDRESS_ID =>V_ADDRESS_ID /*IN NUMBER*/
    );
    SELECT ADDRESS_ID INTO V_ADDRESS_ID
    FROM ADDRESS
    WHERE CITY = 'TAB';
    ADDRESS_PKG.ASSIGN_MEMBER_TO_ADDRESS (
        P_MEMBER_ID => V_GROUP_LEADER_ID /*IN NUMBER*/,
        P_ADDRESS_ID =>V_ADDRESS_ID /*IN NUMBER*/
    );
    SELECT MEMBER_ID INTO V_GROUP_MEMBER_ID
    FROM MEMBERS
    WHERE FIRST_NAME = 'Levente';
    ADDRESS_PKG.ASSIGN_MEMBER_TO_ADDRESS (
        P_MEMBER_ID => V_GROUP_MEMBER_ID /*IN NUMBER*/,
        P_ADDRESS_ID =>V_ADDRESS_ID /*IN NUMBER*/
    );
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        V_ERROR_BACKTRACE := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
        DBMS_OUTPUT.PUT_LINE ( 'Error on init data section' ||'CODE- ' || SQLCODE ||' MSSG' || SQLERRM );
        DBMS_OUTPUT.PUT_LINE ( 'BACKTRACE: '|| V_ERROR_BACKTRACE );
END;